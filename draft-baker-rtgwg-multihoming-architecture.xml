<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- Some of the more generally applicable PIs that most I-Ds might want to use -->
<!-- Try to enforce the ID-nits conventions and DTD validity -->
<?rfc strict="yes" ?>
<!-- Items used when reviewing the document -->
<?rfc comments="no" ?>
<!-- Controls display of <cref> elements -->
<?rfc inline="no" ?>
<!-- When no, put comments at end in comments section,
                                 otherwise, put inline -->
<?rfc editing="no" ?>
<!-- When yes, insert editing marks: editing marks consist of a
                                 string such as <29> printed in the blank line at the
                                 beginning of each paragraph of text. -->
<!-- Create Table of Contents (ToC) and set some options for it.
         Note the ToC may be omitted for very short documents,but idnits insists on a ToC
         if the document has more than 15 pages. -->
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<!-- If "yes" eliminates blank lines before main section entries. -->
<?rfc tocdepth="3"?>
<!-- Sets the number of levels of sections/subsections... in ToC -->
<!-- Choose the options for the references.
         Some like symbolic tags in the references (and citations) and others prefer
         numbers. The RFC Editor always uses symbolic tags.
         The tags used are the anchor attributes of the references. -->
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<!-- If "yes", causes the references to be sorted in order of tags.
                                 This doesn't have any effect unless symrefs is "yes" also. -->
<!-- These two save paper: Just setting compact to "yes" makes savings by not starting each
         main section on a new page but does not omit the blank lines between list items.
         If subcompact is also "yes" the blank lines between list items are also omitted. -->
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<!-- end of list of popular I-D processing instructions -->
<!-- end of list of processing instructions -->
<rfc category="std" docName="draft-baker-rtgwg-multihoming-architecture-00"
     ipr="trust200902">
  <front>
    <title abbrev="">Enterprise Routing Requirements to Support Multihoming using 
	Provider-Assigned Addresses without Network Prefix Translation</title>

    <author fullname="Fred Baker" initials="F.J." surname="Baker">
      <organization>Cisco Systems</organization>
      <address>
        <postal>
          <street/>
          <city>Santa Barbara</city>
          <code>93117</code>
          <region>California</region>
          <country>USA</country>
        </postal>
        <email>fred@cisco.com</email>
      </address>
    </author>

    <author fullname="Chris Bowers" initials="C." surname="Bowers">
      <organization>Juniper Networks</organization>
      <address>
        <postal>
          <street/>
          <city>Sunnyvale</city>
          <code>94089</code>
          <region>California</region>
          <country>USA</country>
        </postal>
        <email>cbowers@juniper.net</email>
      </address>
    </author>
	
    <author fullname="Jen Linkova" initials="J." surname="Linkova">
      <organization>Google</organization>
      <address>
        <postal>
          <street/>
          <city>Mountain View</city>
          <code>94043</code>
          <region>California</region>
          <country>USA</country>
        </postal>
        <email>furry@google.com</email>
      </address>
    </author>
	
    <date/>

    <area>Routing Area</area>

    <workgroup>Routing Working Group</workgroup>

    <abstract>
      <t>asdf s
	  
	  
	  </t>
    </abstract>

  </front>

  <middle>


<section title="Introduction">

<t>  Connecting an enterprise site to multiple ISPs is commonly
used to provide redundant uplinks to different ISPs.  
If the site uses provider-independent(PI) addresses, all traffic
originating from the enterprise can use source addresses from the PI 
address space.  Site multihoming with PI addresses is commonly used 
with both IPv4 and IPv6, and does not present any new technical challenges.
</t> 

<t>  It may be desireable for an enterprise site to connect to multiple ISPs
using provider-assigned(PA) addresses, instead of PI addresses.  Multihoming with 
provider-assigned addresses is typically less expensive for the enterprise 
relative to using provider-independent addresses.  PA multihoming is also 
a practice that should be facilitated and encouraged because it does not 
add to the size of the Internet routing table, whereas PI multihoming does.  
</t>

<t> With PA multihoming,
for each ISP connection, the site is assigned a prefix from within an address 
block allocated to that ISP by its National or Regional Internet Registry.  
In the simple case of two ISPs (ISP-A and ISP-B), the site will have two
different prefixes assigned to it (prefix-A and prefix-B). This arrangement is 
problematic.  First, packets with the "wrong" source address may 
be dropped by one of the ISPs. 
In order to limit denial of service attacks using spoofed source addresses, 
<xref target="RFC2827">BCP38</xref> recommends that ISPs
filter traffic from customer sites to only allow traffic with a source 
address that has been assigned by that ISP.  So a packet 
sent from a multihomed site on the uplink to ISP-B with a source address
in prefix-A may be dropped by ISP-B.  
</t>

<t>However, even if ISP-B does not implement BCP38 or ISP-B adds
prefix-A to its list of allowed source addresses on the uplink from the multihomed 
site, two-way communication may still fail. If the packet with source address in prefix-A was sent to 
ISP-B because the uplink to ISP-A failed, then 
if ISP-B does not drop the packet and the packet reaches its destination 
somewhere on the Internet, the return packet will be sent 
back with a destination address in prefix-A.  The return packet will be routed over 
the Internet to ISP-A, but it will not be delivered to the multihomed
site because its link with ISP-A has failed.  Two-way communication 
would require some arrangement for ISP-B to advertise prefix-A when 
the uplink to ISP-A fails.
</t>

<t>With IPv4, this problem is commonly solved by using <xref target="RFC1918"/> 
private address space within the multi-homed site and 
Network Address Translation (NAT) or Network Address/Port Translation (NAPT) 
on the uplinks to the ISPs.  However, one of the goals of IPv6 is to eliminate
the need for and the use of NAT or NAPT.  Therefore, requiring the use of NAT or NAPT 
for an enterprise site to multihome with provider-assigned adresses is not an
attractive solution.  
</t>

<t> <xref target="RFC6296"/> describes a translation solution
specifically tailored to meet the requirements of multi-homing
with provider-assigned IPv6 addresses. With the
IPv6-to-IPv6 Network Prefix Translation (NPTv6) solution, within the site
an enterprise can use Unique Local Addresses <xref target="RFC4193"/>
or the prefix assigned by one of the ISPs.
As traffic leaves the site on an uplink to an ISP, the 
source address gets translated to an address within the prefix assigned 
by the ISP on that uplink in a predictable and reversible manner.
<xref target="RFC6296"/> is currently classified as Experimental, 
and it has been implemented by several vendors. See <xref target="sec_nptv6"/>,
for more discussion of NPTv6.
</t>

<t>This document defines routing requirements for enterprise multihoming 
using provider-assigned IPv6 addresses. We have made no attempt to 
write these requirements in a 
manner that is agnostic to potential solutions. Instead, this 
document focuses on the following general class of solutions. 
</t>

<t>Each host at the enterprise has multiple addresses, at least one from 
each ISP-assigned prefix. Each host is responsible for choosing which source 
address to apply to each packet it sends. A host should be able respond 
dynamically to the failure of an uplink to a given ISP by no longer 
sending packets with the source address corresponding to that ISP. The 
potential mechanisms to communicate information about changes in the 
network to the host are Neighbor Discovery Router Advertisements, 
DHCPv6, and ICMP. </t> 

<t>The routers in the enterprise network are responsible for ensuring 
that packets are delivered to the "correct" ISP uplink based on source address.
This requires that at least some routers in the site network are able to take
into account the source address of a packet when deciding how to route it. That is, 
some routers must be capable of some form of Source Address Dependent Routing (SADR).
At a minimum, the routers connected to the ISP uplinks (the site exit routers or SERs)
must be capable of Source Address Dependent Routing.  Expanding the connected domain
of routers capable of SADR from the site exit routers deeper into the site network 
will generally result in more efficient routing of traffic with external destinations.
</t>

<t>The document first looks in more detail at the enterprise networking
environments in which this solution is expected to operate. It then discusses
existing and proposed mechansisms for hosts to select the source address applied 
to packets. Finally, it looks at the requirements for routing that are needed 
to support these enterprise network scenarios and the mechanisms by which hosts
are expected to select source addresses dynamically based on network state.
</t>

</section>


<section anchor="sec_enterprise_req" title="Enterprise Multihoming Requirements">


<section anchor="sec_simple_scenario" title="Simple Multihoming Scenario">
<t>We start by looking at a simple scenario where a site has connections to two ISPs,
as shown in <xref target="fig_simple_scenario"/>.
The site is assigned the prefix 2001:db8:0:a000::/52 by ISP-A 
and prefix 2001:db8:0:b000::/52 by ISP-B. 
We consider three hosts in the site.  H31 and H32 are on a LAN  
that has been assigned subnets 2001:db8:0:a010::/64 and 
2001:db8:0:b010::/64.  H31 has been assigned the addresses 
2001:db8:0:a010::31 and 2001:db8:0:b010::31.  H32 has been assigned 
2001:db8:0:a010::32 and 2001:db8:0:b010::32.
H41 is on a different subnet that has been 
assigned 2001:db8:0:a020::/64 and 2001:db8:0:b020::/64.  
</t>



<figure anchor="fig_simple_scenario" title="Simple multihoming scenario " align="center">
<artwork align="center"><![CDATA[
                                        2001:db8:0:a010::101   H101
                                                                 |
                                                                 |
2001:db8:0:a010::31                                          --------
2001:db8:0:b010::31                            ,-----.      /        \
                   +--+   +--+       +----+  ,'       `.   :          :
               +---|R1|---|R4|---+---|SERa|-+   ISP-A   +--+--        :
          H31--+   +--+   +--+   |   +----+  `.       ,'   :          :
               |                 |             `-----'     : Internet :
               |                 |                         :          :
               |                 |                         :          :
               |                 |                         :          :
               |                 |             ,-----.     :          :
          H32--+   +--+          |   +----+  ,'       `.   :          :
               +---|R2|----------+---|SERb|-+   ISP-B   +--+--        :
                   +--+          |   +----+  `.       ,'   :          :
                                 |             `-----'     :          :
                                 |                         :          :
                   +--+  +--+  +--+                         \        /
          H41------|R3|--|R5|--|R6|                          --------  
                   +--+  +--+  +--+ 

2001:db8:0:a020::41 
2001:db8:0:b020::41

]]></artwork>
</figure>

<t>We refer to a router that connects the site to an ISP as a site edge router(SER).
Several other routers provide connectivity among the internal hosts 
(H31, H32, and H41), as well as connecting the internal 
hosts to the Internet through SERa and SERb.  In this example 
SERa and SERb share a direct connection to each other.  
In <xref target="sec_simple_not_dir_conn"/>,
we consider a scenario where this is not the case.
</t>

<t> For the moment, we assume that the hosts are able to make good choices about 
which source addresses through some mechansism that doesn't involve the routers in the site
network.  Here, we focus on primary task of the routed site network, which is to get packets
efficiently to their destinations, while sending a packet to the ISP that assigned the prefix
that matches the source address of the packet.  In 
<xref target="sec_host_mechanisms"/>, we examine what role the routed network
may play in helping hosts make good choices about source addresses for packets.
</t>

<t>  With this solution, routers will need form of Source Address Dependent Routing, 
which will be new funtionality.  It would be useful if an enterprise site does not 
need to upgrade all routers to support the new SADR functionality in order to support 
PA multi-homing.  We consider if this is possible and what are the tradeoffs of not 
having all routers in the site support SADR functionality.
</t>

<t>In the topology in <xref target="fig_simple_scenario"/>, it is possible to 
support PA multihoming with only SERa and SERb being capable of SADR.  The other routers 
can continue to forward based only on destination address, and exchange routes that 
only consider destination address.  In this scenario, SERa and SERb communicate source-scoped
routing information across their shared connection.  When SERa receives a packet 
with a source address matching prefix 2001:db8:0:b000::/52 , 
it forwards the packet to SERb, which forwards it on
the uplink to ISP-B.  The analogous behavious holds for traffic that SERb recieves with a source
address matching prefix 2001:db8:0:a000::/52.   
</t>

<t>In <xref target="fig_simple_scenario"/>, when only SERa and SERb are capable of 
source address dependent routing, PA multi-homing will work.  However, the paths over which 
the packets are sent will generally not be the shortest paths.  The forwarding paths will 
generally be more efficient as more routers are capable of SADR.  For example, if R4, R2, and R6
are upgraded to support SADR, then can exchange source-scoped routes with SERa and SERb. 
They will thne know to send traffic with a 
source address matching prefix 2001:db8:0:b000::/52 directly to SERb, without sending
it to SERa first.
</t> 

</section>

<section anchor="sec_simple_not_dir_conn" title="Simple multihoming scenario where
SERs are not directly connected">

<t>In <xref target="fig_simple_not_dir_conn"/>, we modify the topology slightly 
by inserting R7, so that SERa and SERb are no longer directly connected.  With
this topology, it is not enough to just enable SADR routing on SERa and SERb to support
PA multi-homing.  There are two solutions to ways to enable PA multihoming in this 
topology.
</t> 

<figure anchor="fig_simple_not_dir_conn" title="Simple multihoming scenario where
SERs are not directly connected " align="center">
<artwork align="center"><![CDATA[
                                        2001:db8:0:1234::101    H101
                                                                 |
                                                                 |
2001:db8:0:a010::31                                          --------
2001:db8:0:b010::31                            ,-----.      /        \
                   +--+   +--+       +----+  ,'       `.   :          :
               +---|R1|---|R4|---+---|SERa|-+   ISP-A   +--+--        :
          H31--+   +--+   +--+   |   +----+  `.       ,'   :          :
               |                 |             `-----'     : Internet :
               |               +--+                        :          :
               |               |R7|                        :          :
               |               +--+                        :          :
               |                 |             ,-----.     :          :
          H32--+   +--+          |   +----+  ,'       `.   :          :
               +---|R2|----------+---|SERb|-+   ISP-B   +--+--        :
                   +--+          |   +----+  `.       ,'   :          :
                                 |             `-----'     :          :
                                 |                         :          :
                   +--+  +--+  +--+                         \        /
          H41------|R3|--|R5|--|R6|                          --------  
                   +--+  +--+  +--+                              |
                                                                 | 
2001:db8:0:a020::41                     2001:db8:0:5678::501    H501
2001:db8:0:b020::41

]]></artwork>
</figure>

<t> One option is to effectively modify the topology by creating a logical tunnel between 
SERa and SERb, using GRE for example.  Although SERa and SERb are not directly connected physically
in this topology, they can be directly connected logically by a tunnel.
</t> 

<t> The other option is to enable SADR functionality on R7.  In this way, R7 will
exchange source-scoped routes with SERa and SERb, making the three routers act as a
single SADR domain.  This illustrates the basic principle that the minimum requirement 
for the routed site network to 
support PA multi-homing is having all of the site exit routers be part of a 
connected SADR domain.  Extending the connected SADR domain beyond that point 
can produce more efficient forwarding paths.
</t> 

</section>

<section anchor="sec_network_operator_expectations" title="Enterprise Network Operator Expectations">

<t> Before considering a more complex scenario, let's look in more detail at the
reasonably simple multihoming scenario in <xref target="fig_simple_not_dir_conn"/> to understand 
what can reasonably be expected from this solution.  As a general guiding principle,
we assume an enterprise network operator will expect a multihomed network to behave as 
close as to a single-homed network as possible.  So a solution that meets those expectations 
where possible is a good thing.
</t> 

<t> For traffic between internal hosts and traffic from outside the site to 
internal hosts, an enterprise network operator would expect there to be 
no visible change in the path taken by this traffic, 
since this traffic does not need to be routed in a way that depends on source address.
It is also reasonable to expect that internal hosts should be able to communicate
with each other using either of their source addresses without restriction.
For example, H31 should be able to communicate with H41 using a packet 
with S=2001:db8:0:a010::31, D=2001:db8:0:b010::41, regardless of the state of 
uplink to ISP-B.  
</t> 

<t>These goals can be accomplished by having all of the routers in the network 
continue to originate normal unscoped destination routes
for their connected networks.  If we can arrange so that these unscoped 
destination routes get used for forwarding this traffic, then we will have accomplished
the goal of keeping forwarding of traffic destined for internal hosts, unaffected by 
the multihoming solution.  
</t>

<t> For traffic destined for external hosts, it is reasonable to expect
that traffic with an source adddress from the prefix assigned by ISP-A to
follow the path to that the traffic would follow if there is no connection 
to ISP-B.  This can be accomplished by having SERa originate a source-scoped 
route of the form (S=2001:db8:0:a000::/52, D=::/0) .  If all of the routers in the
site support SADR, then the path of traffic exiting via ISP-A can match that
expectation.   If some routers don't support SADR, then it is reasonable 
to expect that the path for traffic exiting via ISP-A may be different within the
site.  This is a tradeoff that the enterprise network operator may decide to make.
</t> 

<t> It is important to understand how this multihoming solution behaves 
when an uplink to one of the ISPs fails. To simplify this discussion, 
we assume that all routers in the site support SADR.  
We first start by looking at how the network operates when the uplinks to 
both ISP-A and ISP-B are functioning properly.  SERa originates a source-scoped 
route of the form (S=2001:db8:0:a000::/52, D=::/0), and 
SERb is originates a source-scoped 
route of the form (S=2001:db8:0:b000::/52, D=::/0).  These routes 
are distributed through the routers in the site, 
and they establish within the routers two set of forwarding paths for 
traffic leaving the site.  One set of forwarding paths is for packets
with source address in 2001:db8:0:a000::/52.  The other set of forwarding paths is 
for packets with source address in 2001:db8:0:b000::/52.  The 
normal destination routes which are not scoped to these two source
prefixes play no role in the forwarding. 
Whether a packet exits the site via SERa or via SERb is completely 
determined by the source address applied to the packet by the host. 
So for example, when host H31 sends a packet to host H101 with
(S=2001:db8:0:a010::31, D=2001:db8:0:1234::101), the packet will 
only be sent out the link from SERa to ISP-A.  
</t> 

<t> Now consider what happens when the uplink from 
SERa to ISP-A fails.  The only way for the packets from 
H31 to reach H101 is for H31 to start using the source address
for ISP-B. H31 needs to send the following packet: 
(S=2001:db8:0:b010::31, D=2001:db8:0:1234::101).  As far as 
the forwarding functionality of the site network is concerned,
there is no reason for SERa to stop originating the route of the 
form (S=2001:db8:0:a000::/52, D=::/0) when the uplink
to ISP-A fails, and there is no reason to change the 
forwarding so that a packet 
with source address 2001:db8:0:a010::31 is sent to ISP-B.  
</t> 

<t> This behavior is very different from the behavior that occurs 
with site multihoming using PI addresses or with PA addresses using NAT.  
In these other multi-homing solutions, hosts do not need to 
react to network failures several hops away in order to regain 
internet access.  Instead, a host can be largely unaware of the failure
of an uplink to an ISP.  When multihoming with PA addresses and NAT, 
existing sessions generally need to be re-established after a failure since the 
external host will receive packets from the internal host with a new source 
address.  However, new sessions can be established without any 
action on the part of the hosts. 
</t> 

<t> Another example where the behavior of this multihoming solution
differs significantly from that of multihoming with PI address or with PA 
addresses using NAT is in the ability of the enterprise network operator 
to route traffic over different ISPs based on destination address.  We 
still consider the fairly simple network of 
<xref target="fig_simple_not_dir_conn"/> and assume that uplinks
to both ISPs are functioning.  Assume that the site is multihomed using
PA addresses and NAT, and that SERa and SERb each originate a normal destination 
route for D=::/0, with the route origination dependent on the state of the 
uplink to the respective ISP.
</t>

<t> Now suppose it is observed that an important application running 
between internal hosts and external host H101 experience much better performance 
when the traffic passes through ISP-A
(perhaps because ISP-A provides lower latency to H101.)
When multihoming this site with PI addresses or 
with PA addresses and NAT, the enterprise network operator
can configure SERa to originate into the site network a normal destination route for 
D=2001:db8:0:1234::/64 (the destination prefix to reach H101) that 
depends on the state of the uplink to ISP-A.  When the link to ISP-A is 
functioning, the destination route D=2001:db8:0:1234::/64 will be originated 
by SERa, so traffic from all hosts will use ISP-A to reach H101 based on the 
longest destination prefix match in the route lookup. 
</t>

<t> Implementing the same routing policy is more difficult with the PA multihoming 
solution described in this document since it doesn't use NAT.  By design, the only way to control
where a packet exits this network is by setting the source address of the packet.  Since the 
network cannot modify the source address without NAT, the host must set it.
To implement this routing policy, each host needs to use the source address from the prefix assigned
by ISP-A to send traffic destined for H101.  Mechansisms have been proposed to 
allow hosts to choose the source address for packets in a fine grained manner.  We will discuss 
these proposals in <xref target="sec_host_mechanisms"/>.  However, 
interacting with host operating systems in some manner to ensure a particular source address is chosen
for a particular destination prefix is not what an enterprise network administrator would expect
to have to do to implement this routing policy.
</t>
</section>

<section anchor="sec_more_complex_isp_connectivity" title="More complex ISP connectivity">

<t>The previous sections considered two variations of a simple multihoming scenario where
the site is connected to two ISPs offering only internet connectivity.  It is likely that 
many actual enterprise multihoming scenarios will be similar to this simple example.
However, there are more complex multihoming scenarios that we would like this solution 
to address as well.   
</t>

<t>It is fairly common for an ISP to offer a service in addition
to internet access over the same uplink.  Two variation of this are reflected in 
<xref target="fig_isp_service"/>.  In addition to internet access, 
ISP-A offers a service which requires the site
to access host H51 at 2001:db8:0:5555::51.  The site has 
a single physical and logical connection with ISP-A, and 
ISP-A only allows access to H51 over that connection.
So when H32 needs to access the service at H51
it needs to send packets with (S=2001:db8:0:a010::32, D=2001:db8:0:5555::51)
and those packets need to be forward out the link from SERa to ISP-A.  
</t>


<figure anchor="fig_isp_service" title="Internet access and services offered
 by ISP-A and ISP-B " align="center">
<artwork align="center"><![CDATA[
                                        2001:db8:0:1234::101    H101
                                                                 |
                                                                 |
2001:db8:0:a010::31                                          --------
2001:db8:0:b010::31                            ,-----.      /        \
                   +--+   +--+       +----+  ,'       `.   :          :
               +---|R1|---|R4|---+---|SERa|-+   ISP-A   +--+--        :
          H31--+   +--+   +--+   |   +----+  `.       ,'   :          :
               |                 |             `-----'     : Internet :
               |                 |                |        :          :
               |                 |               H51       :          :
               |                 |     2001:db8:0:5555::51 :          :
               |               +--+                        :          :
               |               |R7|                        :          :
               |               +--+                        :          :
               |                 |                         :          :
               |                 |             ,-----.     :          :
          H32--+   +--+          |  +-----+  ,'       `.   :          :
               +---|R2|-----+----+--|SERb1|-+   ISP-B   +--+--        :
                   +--+     |       +-----+  `.       ,'   :          :
                          +--+                 `--|--'     :          :
 2001:db8:0:a010::32      |R8|                    |         \        /
                          +--+                 ,--|--.       --------   
                            |       +-----+  ,'       `.         |      
                            +-------|SERb2|-+   ISP-B   |        |        
                            |       +-----+  `.       ,'       H501         
                            |                  `-----'  2001:db8:0:5678             
                            |                     |               ::501
                    +--+  +--+                   H61         
           H41------|R3|--|R5|           2001:db8:0:6666::61            
                    +--+  +--+                                     
                                         
2001:db8:0:a020::41                                                 
2001:db8:0:b020::41
]]></artwork>
</figure>


<t> ISP-B illustrates a variation on this scenario.  In addition to 
internet access, ISP-B also offers a service which requires the 
site to access host H61.  The site has two connections to two different
parts of ISP-B (shown as SERb1 and SERb2 in <xref target="fig_isp_service"/>).
ISP-B expects internet traffic to use the uplink from SERb1, while it 
expects it expects traffic destined for the service at H61 to use the 
uplink from SERb2.  For either uplink, ISP-B expects the ingress 
traffic to have a source address matching the prefix it assigned to 
the site, 2001:db8:0:b000::/52.  
</t>

<t> As discussed before, we rely completely on the internal host
to set the source address of the packet properly.  In the case of a 
packet sent by H31 to access the service in ISP-B at H61, we expect the 
packet to have the following addresses: (S=2001:db8:0:b010::31, D=2001:db8:0:6666::61).  
The routed network has two potential ways of distributing routes so that 
this packet exits the site on the uplink at SERb2.
</t>

<t> We could just rely on normal destination routes, without using source-prefix scoped routes.
If we have SERb2 originate a normal unscoped destination route for D=2001:db8:0:6666::/64,
the packets from H31 to H61 will exit the site at SERb2 as desired.  We should not have to worry 
about SERa needing to originate the same route, because ISP-B should choose a globally unique 
prefix for the service at H61.  
</t>

<t> The alternative is to have SERb2 originate a source-prefix-scoped destination route of the 
form (S=2001:db8:0:b000::/52, D=2001:db8:0:6666::/64).  From a forwarding point of view, the use 
of the source-prefix-scoped destination route would result in traffic with source addresses corresponding 
only to ISP-B being sent to SERb2. Instead, the use 
of the unscoped destination route would result in traffic with source addresses corresponding 
to ISP-A and ISP-B being sent to SERb2, as long as the destination address matches the destination prefix.
It seems like either forwarding behavior would be acceptable.  
</t>

<t> However, from the point of view of the enterprise network administrator trying to configure,
maintaim, and trouble-shoot 
this multihoming solution, it seems much clearer to have SERb2 originate the source-prefix-scoped
destination route correspond to the service offered by ISP-B.
In this way, all of the traffic leaving the site is determined by the source-prefix-scoped routes,
and all of the traffic within the site or arriving from external hosts is determined by 
the unscoped destination routes.  Therefore, for this multihoming solution we choose to originate 
source-prefix-scoped routes for all traffic leaving the site.
</t>

</section>

<section anchor="sec_isps_and_pa_prefixes" title="ISPs and Provider-Assigned Prefixes">
<t> While we expect that most site multihoming involves connecting to only two ISPs,
this solution allows for conections to an arbitrary number of ISPs to be supported.
However, when evaluating scalable implementations of the solution, it would be reasonable to assume
that the maximum number of ISPs that a site would connect to is five.
</t>

<t> It is also useful to note that the prefixes assigned to the site by different ISPs
will not overlap.  This must be the case , since the provider-assigned 
addresses have to be globablly unique.
</t>
</section>

<section anchor="sec_simpler_topologies" title="Simpler topologies">
<t> The topologies of many enterprise sites using this multihoming solution may 
in practice be simpler than the examples that we have used. The topology
in  <xref target="fig_simple_scenario"/> could be further simplified by having 
all hosts directly connected to the LAN connecting the two site exit routers, 
SERa and SERb.  The topology could also be simplified by having the
uplinks to ISP-A and ISP-B both connected to the same site exit router.
However, it is the aim of this draft to provide a solution that applies to 
a broad a range of enterprise site network topologies, so 
this draft focuses on providing a solution to the more general case.
The simplified cases will also be supported by this solution, but they 
are not the primary target of this solution.
</t>
</section>

</section>

<section anchor="sec_method" title="Generating
 Source-Prefix-Scoped Forwarding Tables">
 <t> So far we have described in general terms how the routers in this solution that are capable 
 of Source Address Dependent Routing will forward traffic using both normal unscoped
 destination routes and source-prefix-scoped destination routes.  Here we give a precise method 
 for generating a source-prefix-scoped forwarding table on a router that supports SADR.
</t>
 
<t> 
<list>

<t>
1) Compute the next-hops for the source-prefix-scoped destination prefixes using 
only routers in the connected SADR domain. These are the initial source-prefix-scoped
forwarding table entries.
</t>

<t>
2) Compute the next-hops for the unscoped destination prefixes using all routers
in the IGP.  This is the unscoped forwarding table.
</t>

<t>
3) Augment each source-prefix-scoped forwarding table with unscoped 
forwarding table entries based on the following rule. If the destination 
prefix of the unscoped forwarding entry exactly matches the destination 
prefix of an existing source-prefix-scoped forwarding entry (including 
destination prefix length), then do not add the unscoped forwarding 
entry. If the destination prefix does NOT match an existing enty, then 
add the entry to the source-prefix-scoped forwarding table. 
</t>

</list>
</t>
 
<t>
The forward tables produced by this process are used in the following way to forward packets.

<list>

<t>
1) If the source address of the packet matches one of the source 
prefixes, then look up the destination address of the packet in the 
corresponding source-prefix-scoped forwarding table to determine the 
next-hop for the packet. 
</t>

<t>
2) If the source address of the packet does NOT match one of the source 
prefixes, then look up the destination address of the packet in unscoped 
forwarding table to determine the next-hop for the packet. 
</t>

</list>
</t>

<t> The following example illustrates how this process is used to create
a forwarding table for each provider-assigned source prefix.  We consider the
multihomed site network in <xref target="fig_isp_service"/>. Initially we assume
that all of the routers in the site network support SADR. 
<xref target="fig_routes_originated"/> shows the routes that are originated by the routers 
in the site network.
</t>

<figure anchor="fig_routes_originated" title="Routes Originated by Routers in the Site Network"
 align="center">
<artwork align="left"><![CDATA[
Routes originated by SERa:
(S=2001:db8:0:a000::/52, D=2001:db8:0:5555/64)
(S=2001:db8:0:a000::/52, D=::/0)
(D=2001:db8:0:5555::/64)
(D=::/0)

Routes originated by SERb1:
(S=2001:db8:0:b000::/52, D=::/0)
(D=::/0)

Routes originated by SERb2:
(S=2001:db8:0:b000::/52, D=2001:db8:0:6666::/64)
(D=2001:db8:0:6666::/64)

Routes originated by R1:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R2:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R3:
(D=2001:db8:0:a020::/64)
(D=2001:db8:0:b020::/64)
]]></artwork>
</figure>

<t> Each SER originates destination routes which are scoped to the source prefix assigned
by the ISP that the SER connects to.  Note that the SERs also originate the corresponding 
unscoped destination route.  This is not needed when all of the routers in the site support
SADR.  However, it is required when some routers do not support SADR.  This will be discussed 
in more detail later.
</t>

<t> We focus on how R8 constructs its source-prefix-scoped forwarding tables
from these route advertisements. R8 computes the next hops for destination routes which are scoped to the 
source prefix 2001:db8:0:a000::/52. The results are shown in the first table 
in <xref target="fig_forwarding_entries"/>.
(In this example, the next hops are computed assuming that all links have the same metric.)
Then, R8 computes the next hops 
for destination routes which are scoped to the 
source prefix 2001:db8:0:b000::/52. The results are shown in the second table 
in <xref target="fig_forwarding_entries"/> .
Finally, R8 computes the next hops for the unscoped destination
prefixes.  The results are shown in the third table in <xref target="fig_forwarding_entries"/>.
</t>

<figure anchor="fig_forwarding_entries" title="Forwarding Entries Computed at R8"
 align="center">
<artwork align="left"><![CDATA[
forwarding entries scoped to 
source prefix = 2001:db8:0:a000::/52
============================================
D=2001:db8:0:5555/64      NH=R7
D=::/0                    NH=R7

forwarding entries scoped to 
source prefix = 2001:db8:0:b000::/52
============================================
D=2001:db8:0:6666/64      NH=SERb2
D=::/0                    NH=SERb1

unscoped forwarding entries
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=SERb1
]]></artwork>
</figure>

<t> The final step is for R8 to augment the source-prefix-scoped 
forwarding entries with unscoped forwarding entries.  
If an unscoped forwarding entry has the exact same destination prefix 
as an source-prefix-scoped forwarding entry (including destination prefix length), 
then the source-prefix-scoped forwarding entry wins.
</t>

<t> As as an example of how the source scoped forwarding entries are augmented
with unscoped forwarding entries, we consider  how the two entries in the 
first table in <xref target="fig_forwarding_entries"/> 
(the table for source prefix = 2001:db8:0:a000::/52)
are augmented with entries from the third table in <xref target="fig_forwarding_entries"/>
(the table of unscoped forwarding entries).  The first four unscoped forwarding 
entries (D=2001:db8:0:a010::/64, D=2001:db8:0:b010::/64, D=2001:db8:0:a020::/64, 
and D=2001:db8:0:b020::/64) are not an exact match for any of the existing entries in the
forwarding table for source prefix 2001:db8:0:a000::/52.  Therefore,  
these four entries are added to the final forwarding table for source prefix 2001:db8:0:a000::/52.  
The result of adding these entries is reflected in first four entries the first 
table in <xref target="fig_forwarding_tables"/>.  
</t>

<t> The next unscoped forwarding table entry is for D=2001:db8:0:5555::/64.  This entry
is an exact match for the existing entry in the
forwarding table for source prefix 2001:db8:0:a000::/52.  Therefore, we do not replace 
the existing entry with the entry from the unscoped forwarding table.  This is reflected 
in the fifth entry in the first table in <xref target="fig_forwarding_tables"/>.  (Note
that since both scoped and unscoped entries have R7 as the next hop, the result of 
applying this rule is not visible.)
</t>

<t> The next unscoped forwarding table entry is for D=2001:db8:0:6666::/64. This entry is not an exact match 
for any existing entries in the forwarding table for source prefix 
2001:db8:0:a000::/52. Therefore, we add this entry. This is reflected 
in the sixth entry in the first table in <xref 
target="fig_forwarding_tables"/>. 
</t>

<t> The next unscoped forwarding table entry is for D=::/0. This entry is 
an exact match for the existing entry in the forwarding table for source 
prefix 2001:db8:0:a000::/52. Therefore, we do not overwrite the 
existing source-prefix-scoped entry, as can be seen in the last 
entry in the first table in <xref target="fig_forwarding_tables"/>.
</t> 

<figure anchor="fig_forwarding_tables" title="Complete Forwarding Tables Computed at R8"
 align="center">
<artwork align="left"><![CDATA[

if source address matches 2001:db8:0:a000::/52
then use this forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=R7

else if source address matches 2001:db8:0:b000::/52
then use this forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=SERb1

else use this forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=SERb1
]]></artwork>
</figure>

<t> The forwarding tables produced by this process at R8 have the desired properties.
A packet with a source address in 2001:db8:0:a000::/52 will be forwarded based on the 
first table in <xref target="fig_forwarding_tables"/>.
If the packet is destined for the internet at large or the service at
D=2001:db8:0:5555/64, it will be sent to R7 in the direction of SERa.
If the packet is destined for an internal host, then the first four entries will send
it to R2 or R5 as expected.  Note that if this packet has a destination address corresponding
to the service offered by ISP-B (D=2001:db8:0:5555::/64), then it will get 
forwarded to SERb2.  It will be dropped by SERb2 or by ISP-B, since it the packet has a 
source address that was not assigned by ISP-B.  However, this is expected behavior.  In order
to use the service offered by ISP-B, the host needs to originate the packet with a source 
address assigned by ISP-B.  
</t> 

<t> In this example, a packet with a source address that doesn't match 2001:db8:0:a000::/52 or 
2001:db8:0:b000::/52 must have originated from an external host.  Such a packet will use the unscoped 
forwarding table (the last table in <xref target="fig_forwarding_tables"/>).  These packets will 
flow exactly as they would in absence of multihoming.  
</t> 

<t> We can also modify this example to illustrate how it supports deployments where 
not all routers in the site support SADR.  Continuing with the topology shown in 
<xref target="fig_isp_service"/>, suppose that R3 and R5 do not support SADR.
Instead they are only capable of understanding unscoped route advertisements.  
The SADR routers in the network will still originate the routes 
shown in <xref target="fig_routes_originated"/>.  However, R3 and R5 will only 
understand the unscoped routes as shown in <xref target="fig_routes_understood_by_non_SADR"/>.
</t> 

<figure anchor="fig_routes_understood_by_non_SADR" title="Routes Advertisements Understood by Routers
that do no Support SADR"
 align="center">
<artwork align="left"><![CDATA[
Routes originated by SERa:
(D=2001:db8:0:5555::/64)
(D=::/0)

Routes originated by SERb1:
(D=::/0)

Routes originated by SERb2:
(D=2001:db8:0:6666::/64)

Routes originated by R1:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R2:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R3:
(D=2001:db8:0:a020::/64)
(D=2001:db8:0:b020::/64)
]]></artwork>
</figure>

<t> With these unscoped route advertisements, R5 will produce the forwarding table shown in 
<xref target="fig_R5_forwarding_table"/>.
</t> 

<figure anchor="fig_R5_forwarding_table" title="Forwarding Table for R5, which doesn't 
Understand Source-Prefix-Scoped Routes"
 align="center">
<artwork align="left"><![CDATA[
forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R8
D=2001:db8:0:b010::/64    NH=R8
D=2001:db8:0:a020::/64    NH=R3
D=2001:db8:0:b020::/64    NH=R3
D=2001:db8:0:5555::/64    NH=R8
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=R8
]]></artwork>
</figure>

<t> Any traffic that needs to exit the site will eventually hit a SADR-capable
router.  Once that traffic enters the SADR-capable domain, then it will not leave that 
domain until it exits the site.  This property is required in order to guarantee that 
there will not be routing loops involving SADR-capable and non-SADR-capable routers.
</t> 

</section>

<section anchor="sec_host_mechanisms" title="Mechanisms for hosts to choose good source addresses in a multihomed site">
<t> Until this point, we have made the assumption that hosts are able to choose the correct 
source address using some unspecified mechanism.  This has allowed us to just focus on 
what the routers in a multihomed site network need to do in order to forward packets 
to the correct ISP based on source address.  Now we look at possible mechanisms for hosts 
to choose the correct source address.  We also look at what role, if any, the routers may play 
in providing information that helps hosts to choose source addresses.  
</t>

<t> Until this point, we have made the assumption that hosts are able to choose the correct 
source address using some unspecified mechanism.  This has allowed us to just focus on 
what the routers in a multihomed site network need to do in order to forward packets 
to the correct ISP based on source address.  Now we look at possible mechanisms for hosts 
to choose the correct source address.  We also look at what role, if any, the routers may play 
in providing information that helps hosts to choose source addresses.  
</t>

<t> Any host that needs to be able to communicate using the uplinks to a given ISP is expected to be
configured with an address from the prefix assigned by that ISP.  The host will 
control which ISP is used for its traffic by selecting one of the addresses configured on 
the host as the source address for outgoing traffic.  It is the responsibility of the site
network to ensure that a packet with the source address from an ISP is not sent on an uplink to 
that ISP.
</t>

<t> If all of the ISP uplinks are working, the choice of source address by the host 
may be driven by the desire to load share across ISP uplinks, or it may be driven by the desire to 
take advantage of certain properties of a particular uplink or ISP.  If any of the ISP uplinks 
is not working, then the choice of source address by the host can determine if packets get dropped.   
</t>

<t> How a host should make good decisions about source address selection in a multihomed
site is not a solved problem.  We do not attempt to solve this problem in this document. 
Instead we discuss the current state of affairs with respect to standardized solutions and
implementation of those solutions.  We also look at proposed solutions for this problem.
</t>

<t> An external host initiating communication with a host internal to a PA multihomed site
will need to know multiple addresses for that host in order to communicate with it using
different ISPs to the multihomed site. These addresses are typically learned through DNS.  
(For simplicity, we assume that the external host is single-homed.)
The external host chooses the ISP that will be used at the remote multihomed site by setting
the destination address on the packets it transmits. For a sessions 
originated from an external host to an internal host, the choice of source address
used by the internal host is simple.  The internal host has no choice but to use the destination 
address in the received packet as the source address of the transmitted packet.   
</t>


<section anchor="sec_sessions_from_internal_hosts" title="Sessions initiated from internal hosts">
<t> For a session originated by a host internal to the multi-homed site, the decision of what source 
address to select is more complicated.  There are three main ways for hosts to get information about the 
network:  Neighbor Discovery Router Advertisements (RAs), DHCPv6, and ICMPv6.  Note that we are explicitly
excluding the possibility of having hosts participate in or even listen directly
to routing protocol advertisements.
</t>

<t> First we look at how a host is currently expected to select the source and destination address 
with which it sends a packet.  
</t>

<section anchor="sec_host_address_selection_algo" title="Source Address Selection Algorithm on Hosts">
<t> 
<xref target="RFC6724"/> defines the algorithms that hosts are expected to use to select source and destination 
addresses for packets.  It defines an algorithm for selecting a source address and a separate algorithm for selecting
a destination address.  Both of these algorithms depend on a policy table. <xref target="RFC6724"/> defines a 
default policy which produces certain behavior.  
</t>

<t> The rules in the two algorithms in <xref target="RFC6724"/> depend on many different properties of addresses.
While these are needed for understanding how a host should choose addresses in an arbitary environment, most of 
the rules are not relevant for understanding how a host should choose among mulitple source addresses when sending 
a packet to a remote host. Returning to the example in <xref target="fig_isp_service"/>, we look 
at what the default algorithms in <xref target="RFC6724"/> say about the source address that 
internal host H31 should use to send traffic to external host H101, somewhere on the Internet.
Let's look at what rules in <xref target="RFC6724"/> are actually used by H31 in this case.
</t>

<t> There is no choice to be made with respect to destination address.
H31 needs to send a packet with D=2001:db8:0:1234::101 in order to reach H101.    
So H31 have to choose between using S=2001:db8:0:a010::31 or S=2001:db8:0:b010::31 as the source 
address for this packet.  We go through the rules for source address selection in 
Section 5 of <xref target="RFC6724"/>.  Rule 1 (Prefer same address) is not useful 
to break the tie between source addresses,
because neither the candidate source addresses equals the destination address.
Rule 2 (Prefer appropriate scope) is also not used in this scenario,  
because both source addresses and the
destination address have global scope.  
</t>

<t>
Rule 3 (Avoid deprecated addresses) applies to an address that has been
autoconfigured by a host using stateless address autoconfiguration as 
defined in <xref target="RFC4862"/>. An address autoconfigured by a 
host has a preferred lifetime and a valid lifetime.  The address is 
preferred until the preferred lifetime expires, after which it 
becomes deprecated.  A deprecated address can still be used, but 
it is better to use a preferred adddress.  When the valid lifetime 
expires, the address cannot be used at all.  The preferred and 
valid lifetimes for an autoconfigured address are set based on the 
corresponding lifetimes in the Prefix Information Option  in 
Neighbor Discovery Router Advertisements.  So a possible tool to 
control source address selection in this scenario would be to a host to make 
an address deprecated (or invalid) by having routers on that link, 
R1 and R2 in <xref target="fig_isp_service"/>, 
send Prefix Information Option messages with the preferred (or valid) lifetime for the source 
prefix to be discouraged (or prohibited) set to zero.  
This is a rather blunt tool, because it discourges or prohibits the 
use of that source prefix for all destinations.  However, it may be useful
in some scenarios.  In the list of relevant source address selection 
rules below, we have created a rule 0 to capture the possibility of prohibiting
the use of a source address by making it invalid via Prefix Information Option messages.  
</t>

<t>Rule 4 (Avoid home addresses) does not apply here because we are not 
considering Mobile IP.  Rule 5 (Prefer outgoing interface) is not useful 
in this scenario, because both source addresses are assigned
to the same interface.  Rule 5.5 is also 
not useful in this scenario, because
both R1 and R2 will advertise both source prefixes.   
</t>

<t>Rule 6 (Prefer matching label) refers to the Label value determined for 
each source and destination prefix as a result of applying the policy table to 
the prefix.  With the default policy table defined in 
Section 2.1 of <xref target="RFC6724"/>, Label(2001:db8:0:a010::31) = 5, 
Label(2001:db8:0:b010::31) = 5,  and Label(2001:db8:0:1234::101) = 5.  So with
the default policy, Rule 6 does not break the tie.  However, the algorithms
in <xref target="RFC6724"/> are defined in such as way that non-default address selection policy
tables can be used.  
<xref target="RFC7078"/> defines a way to distribute a non-default
address selection policy table to hosts using DHCPv6.  So even though the application 
of rule 6 to this scenario using the default policy table is not useful, rule 6
may still be a useful tool.
</t>

<t> Rule 7 (Prefer temporary addresses) has to do
 with the technique described in <xref target="RFC4941"/> to periodically 
 randomize the interface portion of an IPv6 address that
 has been generated using stateless
 address autoconfiguration.  In general, if H31 were using this technique, it would 
 use it for both source addresses, for example creating temporary addresses 
2001:db8:0:a010:2839:9938:ab58:830f and 2001:db8:0:b010:4838:f483:8384:3208, in addition 
to 2001:db8:0:a010::31 and 2001:db8:0:b010::31.  So this rule would prefer the two 
temporary addresses, but it would not break the tie between the two source prefixes 
from ISP-A and ISP-B.  
</t>

<t> So we can see that of the 7 source selection address rules from <xref target="RFC6724"/>, 
only a few actually apply to our basic site multihoming scenario.  The rules that are 
relevant to this scenario are summarized below.  
</t>

<t>
<list>
<t>
Rule 0: Only uses valid addresses.  
</t>
<t>
Rule 3: Avoid deprecated addresses.
</t>
<t>
Rule 6: Prefer matching label.
</t>
</list>
</t>

<t> The two main methods that we consider for controlling the source address selection through the three
relevant rules above are Neighbor Discovery Router Advertisment messages and DHCPv6. 
</t>

<t>We also consider a possible role for ICMPv6 for getting 
traffic-driven feedback from the network. With the source address 
selection algorithm discussed above, the goal is to choose the correct 
source address on the first try, before any traffic is sent. However, 
another strategy is to choose a source address, send the packet, get 
feedback from the network about whether or not the source address is 
correct, and try another source address if it is not. 
</t>

<t> We consider two common scenarios where a host needs to select the correct source address. 
The first is when both uplinks are working.  The second is when one uplink has
failed.
</t>
</section>

<section anchor="sec_both_uplinks_working" title="Selecting Source Address When Both Uplinks Are Working">
<t> Again we return to the topology in <xref target="fig_isp_service"/>. 
Suppose that that site admininistrator wants to implement a policy by 
which all hosts need to use ISP-A to reach H01 at D=2001:db8:0:1234::/64.  So for example,
H31 needs to select S=2001:db8:0:a010::31.
</t>

<section anchor="sec_both_working_dhcpv6" title="Distributing address selection policy table with DHCPv6">
<t> This policy can be implemented by using DHCPv6 to distribute an address selection policy table 
that assigns the same label to destination address that match 2001:db8:0:1234::/64 as it does to source 
addresses that match 2001:db8:0:a000::/52.  The following two entries accomplish this.
</t>

<figure anchor="fig_policy_table" title="Policy table entries " align="center">
<artwork align="center"><![CDATA[
Prefix                 Precedence       Label            
2001:db8:0:1234::/64   50               33
2001:db8:0:a000::/52   50               33
]]></artwork>
</figure>

<t> This requires that the hosts implement <xref target="RFC6724"/>, the basic source and destination 
address framework, along with <xref target="RFC7078"/>, the DHCPv6 extension for distributing a 
non-default policy table.  Note that it does NOT require that the hosts use DHCPv6 for address assignment.
The hosts could still use stateless address autoconfiguration for address configuration, while  
using DHCPv6 only for policy table distribution (see <xref target="RFC3736"/>).  
</t>
</section>

<section anchor="sec_both_working_ra" title="Controlling Source Address Selection With Router Advertisements">
<t> Neighbor Discovery currently has two mechanisms to communicate 
prefix information to hosts. The base specification for Neighbor Discovery (see <xref target="RFC4861"/>)
defines the Prefix Information Option (PIO) in the Router Advertisement (RA) message. 
When a host
receives a PIO with the A-flag set, it can use the prefix in the PIO as source prefix 
from which it assigns itself an IP address using stateless address autoconfiguration (SLAAC) procedures
described in <xref target="RFC4862"/>.  In the example of <xref target="fig_isp_service"/>,
if the site network is using SLAAC,
we would expect both R1 and R2 to send RA messages with PIOs for both source prefixes
2001:db8:0:a010::/64 and 2001:db8:0:b010::/64 with the A-flag set.  H31 would then 
use the SLAAC procedure to configure itself with the 2001:db8:0:a010::31  
and 2001:db8:0:b010::31.  
</t>

<t> Whereas a host learns about source prefixes from PIO messages,  hosts 
can learn about a destination prefix from a Router Advertisement containing
Route Information Option (RIO), as specified in <xref target="RFC4191"/>.  
The destination prefixes in RIOs are intended to allow a host to choose 
the router that it uses as its first hop to reach a particular destination prefix.  
</t>

<t> As currently standardized, neither PIO nor RIO options contained in Neigbor Discovery
Router Advertisements can communicate the information needed to implement the desired
routing policy.  PIO's communicate source prefixes, and RIO communicate destination prefixes.
However, there is currently no standardized way to associate a particular destination prefix
with a particular source prefix.  
</t>

<t> <xref target="I-D.pfister-6man-sadr-ra"/> 
proposes a Source Address Dependent Route Information option for 
Neighbor Discovery Router Advertisements which would associate a source 
prefix and with a destination prefix.  The details of 
<xref target="I-D.pfister-6man-sadr-ra"/> might need tweaking to address 
this use case.  However, in order to be able to use Neighbor Discovery 
Router Advertisements to implement this routing policy, an extension that
allows a R1 and R2 to explicitly communicate to H31 an association between 
S=2001:db8:0:a000::/52 D=2001:db8:0:1234::/64 would be needed.
</t>

</section>

<section anchor="sec_both_working_icmpv6" title="Controlling Source Address Selection With ICMPv6">
<t> 
 
</t>

</section>

</section>

<section anchor="sec_one_uplink_failed" title="Selecting Source Address When One Uplink Has Failed">
<t> 


</t>

</section>

<section anchor="sec_placeholder1" title="DHCPv6">
<t> 
<xref target="RFC6724"/> defines a policy framework to allow a host to select both 
source addresses and destination addresses.  

Section 2.1 of <xref target="RFC6724"/> defines a default address selection policy that operates within this framework.
, 
the current default address selection policy for IPv6. It uses properties of
the addresses themselves such as scope (link-local, global, etc.) and whether or not the address
is . 

 As section points out that
this default policy fa


<xref target="RFC6724"/> relies on address 

</t>

</section>

</section>

<section anchor="sec_ND_RA" title="Hosts learn information about the network via Neighbor Discovery Router Advertisements">
<t> 

</t>
</section>

<section anchor="sec_DHCPv6" title="Hosts may learn information about the network via DHCPv6">
<t> 

</t>
</section>


</section>


<section anchor="sec_routing_protocol_expectations" title="What we expect the routing protocol to provide">
<t> 

</t>

<section anchor="sec_primary_goal" title="Primary goal: Make sure that packets are always 
delivered to the correct site exit router">
<t> 
Packet should be routed with the following criteria:

1) Forwarding is loop-free
2) Packets are delivered to site exit router whose uplink will accept packets with that source address.


</t>
</section>

<section anchor="sec_secondary_goal" title="Secondary goal: Provide information to routers adjacent to hosts that
can be converted to ND Router Advertisements  which in turn assist the host with source address selection ">
<t> 

</t>
</section>

</section>


<section anchor="sec_asfdadf" title="Two pass route lookup model ">
<t> 
Each router maintains a destination-based route table for 
</t>
</section>

    <section anchor="L3" title="Internet layer (IPv6)">
      <t/>

      <section anchor="L3-sadr" title="SADR forwarding (router)">
        <t>A SADR Router is a router that makes routing and forwarding
        decisions based on both the source and destination addresses in an IP
        packet.</t>

        <t>There are at least three ways one could build the forwarding plane:
        use the source address to select a destination Forwarding Information
        Base (FIB), use the destination address to select a source address FIB
        or filter, or use the two as a combined key in the same mechanism to
        find a source/destination prefix pair in the FIB.</t>

        <t>The first two are well understood; follow a longest-match-first
        rule on the source or destination address in a radix tree or other
        type of database, and do so again with the other address.</t>

        <t>Algorithms exist for the third, such as <xref target="PATRICIA"/>;
        a potentially discontiguous bit pattern (the source and destination
        address) is analyzed to determine what bits are most important at any
        given stage in the lookup, and the lookup trie is organized
        accordingly. TCAMs, of course, look at the entire lookup key
        simultaneously, and are therefore another solution to the third case.
        The counterpart to "longest match first" in such an algorithm is "most
        specific match first".</t>

        <t>An important use case (<xref
        target="I-D.baker-rtgwg-src-dst-routing-use-cases"/>) for
        source/destination routing is in egress routing. Egress routing is
        essentially an enterprise or campus technology that presumes several
        default routes in the network associated with the various prefixes in
        use, and follows the default route for the relevant source prefix to
        an egress to an upstream network. In that formulation, it is a
        degenerate algorithm, perhaps best described as "source-specific"
        routing, as the actual destination (as long is it is not local, which
        would match a more specific route) is irrelevant - much as the source
        address is irrelevant in traditional destination routing.</t>

        <t>Other use cases, of which there are several, provide for the
        possibility of following one of several paths to the same destination
        based on the source prefix selected. That can be implemented as a set
        of default routes with additional more-specific routes.</t>
      </section>

      <section anchor="L3-addressing"
               title="Intelligent source address selection for a given destination">
        <t>Source address selection in IPv6 has been a challenge. The biggest
        single part of the challenge is that the host has no real
        understanding of the network it finds itself in; at best, it might
        know important parts of recent path state, or what has historically
        worked and some measurements of how well. Unless the host has
        configuration, history, or clairvoyance, it has no provably correct
        mechanism with which to make a selection.</t>

        <t>Existing RFCs on the topic, notably <xref target="RFC6724"/>, seek
        to avoid address formats that have undesirable characteristics, such
        as indicating the use of network address translation when an
        untranslated path is available, using technologies that have not
        worked well in the Internet, or using technologies that are
        politically incorrect. Having eschewed the obviously bad choices, they
        then recommend using the source address most similar to the
        destination, on the premise that this should minimize path length. The
        advice is probably generally good, but may also be suboptimal in
        individual cases.</t>
      </section>

      <section anchor="L3-host-ICMP"
               title="Reacting to timeouts and ICMP messages">
        <t>When a packet does something other than follow the most obvious
        path to its destination and arrive, the Internet Architecture
        generally expects the router or middleware discarding it to inform the
        sender why not. It does so using the <xref target="RFC4443">Internet
        Control Message Protocol</xref>.</t>

        <t>There are a number of cases in which that general dictum is not
        followed; link layer corruption may make the packet unintelligible, so
        that no system actually receives it to choose to drop it, the system
        dropping the packet may be configured to not send, or to rate limit
        the rate at which it sends, ICMP messages, and a filter en route may
        prevent the ICMP message from arriving. In such cases, the sender is
        left to intuit the failure from a timeout and take such corrective
        action as may be required.</t>

        <t>In a network with one prefix, the recovery action is simple: either
        retransmit, or inform the application that the session failed.</t>

        <t>In a network with more than one prefix (which might mean "has both
        an IPv4 and an IPv6 prefix", "has IPv4 or IPv6 prefixes on different
        interfaces", or "has more than one prefix, IPv4 or IPv6, on the same
        interface"), one alternative to simple retransmission using the same
        source address is to retransmit using a different source address.
        <xref target="RFC6555">Happy Eyeballs</xref> provides a relatively
        sophisticated way to accomplish that; in the simplest case, the socket
        API can simply select a different one.</t>
      </section>

      <section anchor="L3-host-Next-Hop"
               title="Intelligent first-hop selection (host)">
        <t><xref target="I-D.ietf-6man-multi-homed-host"/> addresses the
        question of first hop selection by a host. This is a routing question
        being answered by a system that in the general case has little
        knowledge of network routing. However, it does know what addresses it
        is using, on what interfaces, and how it obtained them. In a network
        using DHCP/DHCPv6, it knows that it can use as its first hop router a
        router on the interface the source address is associated with, which
        it learns by observing Router Advertisements, and it may have been
        given an ICMP Redirect to a different router. In a network using <xref
        target="RFC4862">IPv6 Stateless Address Autoconfiguration</xref> (in
        any of its variants), it knows what router advertised the prefix to
        it, and can use that as a first hop router.</t>
      </section>

      <section anchor="L3-ephemeral-addresses"
               title="Deal with addresses being ephemeral, interface state and interfaces appearing / disappearing">
        <t/>
      </section>
    </section>

    <section anchor="Routing" title="Routing layer">
      <t/>

      <section anchor="Routing-Protocol"
               title="Routing protocol for source/destination routing">
        <t>A Source/Destination routing protocol is a protocol that exchanges
        the information necessary for the calculation of a SADR FIB, and then
        calculates it. No currently-deployed protocol implements SADR routing
        at this point, although there are experiments in progress. <xref
        target="I-D.baker-ipv6-isis-dst-src-routing">IPv6 Source/Destination
        Routing using IS-IS</xref>, <xref
        target="I-D.xu-src-dst-bgp">Source/Destination Routing Using
        BGP-4</xref>, <xref
        target="I-D.boutier-babel-source-specific">Source-Specific Routing in
        Babel</xref>, and <xref target="RFC7788">Home Networking Control
        Protocol</xref> are examples of source/destination routing
        protocols.</t>
      </section>
    </section>

    <section anchor="L4" title="Transport layer">
      <t/>

      <section anchor="L4-path-fail" title="Handle failure in one path">
        <t/>
      </section>

      <section anchor="L4-load-share" title="Share load across multiple paths">
        <t/>
      </section>

      <section anchor="L4-path-restore"
               title="Bring up path again after failure">
        <t/>
      </section>
    </section>

    <section anchor="L5" title="Session layer">
      <t/>

      <section anchor="L5-session"
               title="Recover session e.g. moving from home to office">
        <t/>
      </section>
    </section>
	
<section anchor="sec_nptv6" title="IPv6-to-IPv6 Network Prefix Translation">

<t>IPv6-to-IPv6 Network Prefix Translation is not the focus of this 
document. This document describes a solution where a host in a 
multihomed site determines which ISP a packet will be sent to based on 
the source address it applies to the packet. This solution has many 
moving parts. It requires 
some routers in the enterprise site to support an as-yet-unspecified 
form of Source Address Dependent Routing (SADR). It requires a host to 
be able to learn when the uplink to an ISP fails so that it can stop 
using the source address corresponding to that ISP. Ongoing work to 
create mechansisms to accomplish this are discussed in this document, 
but they are still a work in progress. 
</t>

<t> The requirements in this document aim at creating a PA multihoming 
solution that is as easy as possible for an enterprise to deploy. However, 
the success of this solution will depend greatly on whether or not the 
as-yet-unspecified mechanisms for hosts to select source addresses based 
on the state of ISP uplinks gets implemented across a wide range of 
operating systems as the default mode of operation.
Until that occurs, NPTv6 should still be 
considered a viable option to enable PA multihoming for enterprises. 
</t>

</section>
	

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo asks the IANA for no new parameters.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t/>

      <section anchor="Privacy" title="Privacy Considerations">
        <t/>
      </section>
	  
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The original outline was suggested by Ole Troan.  
	  <xref target="I-D.huitema-shim6-ingress-filtering"/> discussed the idea
	  using a connected domain of SADR-capable routers, instead of requiring that
	  ever router in the IGP be capable of SADR.
  	  </t>
    </section>
  </middle>

  <back>
    <!-- references split to informative and normative -->

<references title="Normative References">
<?rfc include="reference.RFC.2827" ?>

<?rfc include="reference.RFC.4193" ?>

<?rfc include="reference.RFC.6296" ?>

<?rfc include="reference.RFC.1918" ?>

<?rfc include="reference.RFC.1122" ?>

<?rfc include="reference.RFC.1123" ?>

<?rfc include="reference.RFC.2119"?>

<?rfc include="reference.RFC.2460"?>

<?rfc include="reference.RFC.3582" ?>

<?rfc include="reference.RFC.4116" ?>

<?rfc include="reference.RFC.4191" ?>

      <?rfc include="reference.RFC.4218" ?>

      <?rfc include="reference.RFC.4219" ?>

      <?rfc include="reference.RFC.7157" ?>
    </references>

    <references title="Informative References">

      <?rfc include="reference.I-D.pfister-6man-sadr-ra" ?>

      <?rfc include="reference.I-D.huitema-shim6-ingress-filtering" ?>

      <?rfc include="reference.I-D.baker-ipv6-isis-dst-src-routing" ?>

      <?rfc include="reference.I-D.baker-rtgwg-src-dst-routing-use-cases" ?>

      <?rfc include="reference.I-D.boutier-babel-source-specific" ?>

      <?rfc include="reference.I-D.ietf-6man-multi-homed-host" ?>

      <?rfc include="reference.I-D.ietf-mif-mpvd-arch" ?>

      <?rfc include="reference.I-D.ietf-mptcp-experience" ?>

      <?rfc include="reference.I-D.ietf-rtgwg-dst-src-routing" ?>

      <?rfc include="reference.I-D.xu-src-dst-bgp" ?>

      <?rfc include="reference.RFC.4443" ?>
 
      <?rfc include="reference.RFC.3736" ?>

      <?rfc include="reference.RFC.4861" ?>

      <?rfc include="reference.RFC.4862" ?>

      <?rfc include="reference.RFC.6555" ?>

      <?rfc include="reference.RFC.6724" ?>

      <?rfc include="reference.RFC.7078" ?>
	  
      <?rfc include="reference.RFC.7788" ?>

      <?rfc include="reference.RFC.4941" ?>
	  
      <reference anchor="PATRICIA">
        <front>
          <title>Practical Algorithm to Retrieve Information Coded in
          Alphanumeric</title>

          <author fullname="D.R. Morrison" initials="D.R." surname="Morrison">
            <organization>Association for Computing Machinery</organization>
          </author>

          <date month="October" year="1968"/>
        </front>

        <seriesInfo name="Journal of the ACM" value="15(4) pp514-534"/>

        <format target="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA/"
                type="HTML"/>
      </reference>
    </references>

    <section anchor="log" title="Change Log">
      <t><list style="hanging">
          <t hangText="Initial Version:">June 2016</t>
        </list></t>
    </section>
  </back>
</rfc>
