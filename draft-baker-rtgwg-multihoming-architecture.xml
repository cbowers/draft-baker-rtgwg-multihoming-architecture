<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- Some of the more generally applicable PIs that most I-Ds might want to use -->
<!-- Try to enforce the ID-nits conventions and DTD validity -->
<?rfc strict="yes" ?>
<!-- Items used when reviewing the document -->
<?rfc comments="no" ?>
<!-- Controls display of <cref> elements -->
<?rfc inline="no" ?>
<!-- When no, put comments at end in comments section,
                                 otherwise, put inline -->
<?rfc editing="no" ?>
<!-- When yes, insert editing marks: editing marks consist of a
                                 string such as <29> printed in the blank line at the
                                 beginning of each paragraph of text. -->
<!-- Create Table of Contents (ToC) and set some options for it.
         Note the ToC may be omitted for very short documents,but idnits insists on a ToC
         if the document has more than 15 pages. -->
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<!-- If "yes" eliminates blank lines before main section entries. -->
<?rfc tocdepth="3"?>
<!-- Sets the number of levels of sections/subsections... in ToC -->
<!-- Choose the options for the references.
         Some like symbolic tags in the references (and citations) and others prefer
         numbers. The RFC Editor always uses symbolic tags.
         The tags used are the anchor attributes of the references. -->
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<!-- If "yes", causes the references to be sorted in order of tags.
                                 This doesn't have any effect unless symrefs is "yes" also. -->
<!-- These two save paper: Just setting compact to "yes" makes savings by not starting each
         main section on a new page but does not omit the blank lines between list items.
         If subcompact is also "yes" the blank lines between list items are also omitted. -->
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<!-- end of list of popular I-D processing instructions -->
<!-- end of list of processing instructions -->
<rfc category="std" docName="draft-bowbakova-rtgwg-enterprise-pa-multihoming-00"
     ipr="trust200902">
  <front>
    <title abbrev="">Enterprise Multihoming using 
	Provider-Assigned Addresses without Network Prefix Translation: Requirements and Solution</title>

    <author fullname="Fred Baker" initials="F.J." surname="Baker">
      <organization>Cisco Systems</organization>
      <address>
        <postal>
          <street/>
          <city>Santa Barbara</city>
          <code>93117</code>
          <region>California</region>
          <country>USA</country>
        </postal>
        <email>fred@cisco.com</email>
      </address>
    </author>

    <author fullname="Chris Bowers" initials="C." surname="Bowers">
      <organization>Juniper Networks</organization>
      <address>
        <postal>
          <street/>
          <city>Sunnyvale</city>
          <code>94089</code>
          <region>California</region>
          <country>USA</country>
        </postal>
        <email>cbowers@juniper.net</email>
      </address>
    </author>
	
    <author fullname="Jen Linkova" initials="J." surname="Linkova">
      <organization>Google</organization>
      <address>
        <postal>
          <street/>
          <city>Mountain View</city>
          <code>94043</code>
          <region>California</region>
          <country>USA</country>
        </postal>
        <email>furry@google.com</email>
      </address>
    </author>
	
    <date/>

    <area>Routing Area</area>

    <workgroup>Routing Working Group</workgroup>

<abstract>
<t> Connecting an enterprise site to multiple ISPs using 
provider-assigned addresses is difficult without the use of 
some form of Network Address Translation (NAT).  Much has been written on this 
topic over the last 10 to 15 years, but it still remains 
a problem without a clearly defined or widely implemented solution.
Any multihoming solution without NAT requires hosts at the site to have 
addresses from each ISP and to select the egress ISP by selecting
a source address for outgoing packets.  It also requires routers at the site
to take into account those source addresses when forwarding packets 
out towards the ISPs.
</t>

<t>This document attempts to define a complete
solution to this problem.  It covers the behavior of routers to forward 
traffic taking into account source address, and it covers the behavior
of host to select appropriate source addresses.  It also covers any possible
role that routers might play in providing information to hosts to help them
select appropriate source addresses.  In the process of exploring 
potential solutions, this documents also makes explicit requirements 
for how the solution would be expected to behave from the 
perspective of an enterprise site network administrator .  
</t>
</abstract>

  </front>

  <middle>


<section title="Introduction">

<t>  Connecting an enterprise site to multiple ISPs is commonly
used to provide redundant uplinks to different ISPs.  
If the site uses provider-independent(PI) addresses, all traffic
originating from the enterprise can use source addresses from the PI 
address space.  Site multihoming with PI addresses is commonly used 
with both IPv4 and IPv6, and does not present any new technical challenges.
</t> 

<t>  It may be desireable for an enterprise site to connect to multiple ISPs
using provider-assigned(PA) addresses, instead of PI addresses.  Multihoming with 
provider-assigned addresses is typically less expensive for the enterprise 
relative to using provider-independent addresses.  PA multihoming is also 
a practice that should be facilitated and encouraged because it does not 
add to the size of the Internet routing table, whereas PI multihoming does.  
</t>

<t> With PA multihoming,
for each ISP connection, the site is assigned a prefix from within an address 
block allocated to that ISP by its National or Regional Internet Registry.  
In the simple case of two ISPs (ISP-A and ISP-B), the site will have two
different prefixes assigned to it (prefix-A and prefix-B). This arrangement is 
problematic.  First, packets with the "wrong" source address may 
be dropped by one of the ISPs. 
In order to limit denial of service attacks using spoofed source addresses, 
<xref target="RFC2827">BCP38</xref> recommends that ISPs
filter traffic from customer sites to only allow traffic with a source 
address that has been assigned by that ISP.  So a packet 
sent from a multihomed site on the uplink to ISP-B with a source address
in prefix-A may be dropped by ISP-B.  
</t>

<t>However, even if ISP-B does not implement BCP38 or ISP-B adds
prefix-A to its list of allowed source addresses on the uplink from the multihomed 
site, two-way communication may still fail. If the packet with source address in prefix-A was sent to 
ISP-B because the uplink to ISP-A failed, then 
if ISP-B does not drop the packet and the packet reaches its destination 
somewhere on the Internet, the return packet will be sent 
back with a destination address in prefix-A.  The return packet will be routed over 
the Internet to ISP-A, but it will not be delivered to the multihomed
site because its link with ISP-A has failed.  Two-way communication 
would require some arrangement for ISP-B to advertise prefix-A when 
the uplink to ISP-A fails.
</t>

<t>With IPv4, this problem is commonly solved by using <xref target="RFC1918"/> 
private address space within the multi-homed site and 
Network Address Translation (NAT) or Network Address/Port Translation (NAPT) 
on the uplinks to the ISPs.  However, one of the goals of IPv6 is to eliminate
the need for and the use of NAT or NAPT.  Therefore, requiring the use of NAT or NAPT 
for an enterprise site to multihome with provider-assigned adresses is not an
attractive solution.  
</t>

<t> <xref target="RFC6296"/> describes a translation solution
specifically tailored to meet the requirements of multi-homing
with provider-assigned IPv6 addresses. With the
IPv6-to-IPv6 Network Prefix Translation (NPTv6) solution, within the site
an enterprise can use Unique Local Addresses <xref target="RFC4193"/>
or the prefix assigned by one of the ISPs.
As traffic leaves the site on an uplink to an ISP, the 
source address gets translated to an address within the prefix assigned 
by the ISP on that uplink in a predictable and reversible manner.
<xref target="RFC6296"/> is currently classified as Experimental, 
and it has been implemented by several vendors. See <xref target="sec_nptv6"/>,
for more discussion of NPTv6.
</t>

<t>This document defines routing requirements for enterprise multihoming 
using provider-assigned IPv6 addresses. We have made no attempt to 
write these requirements in a 
manner that is agnostic to potential solutions. Instead, this 
document focuses on the following general class of solutions. 
</t>

<t>Each host at the enterprise has multiple addresses, at least one from 
each ISP-assigned prefix. Each host is responsible for choosing which source 
address to apply to each packet it sends. A host should be able respond 
dynamically to the failure of an uplink to a given ISP by no longer 
sending packets with the source address corresponding to that ISP. The 
potential mechanisms to communicate information about changes in the 
network to the host are Neighbor Discovery Router Advertisements, 
DHCPv6, and ICMP. </t> 

<t>The routers in the enterprise network are responsible for ensuring 
that packets are delivered to the "correct" ISP uplink based on source address.
This requires that at least some routers in the site network are able to take
into account the source address of a packet when deciding how to route it. That is, 
some routers must be capable of some form of Source Address Dependent Routing (SADR).
At a minimum, the routers connected to the ISP uplinks (the site exit routers or SERs)
must be capable of Source Address Dependent Routing.  Expanding the connected domain
of routers capable of SADR from the site exit routers deeper into the site network 
will generally result in more efficient routing of traffic with external destinations.
</t>

<t>The document first looks in more detail at the enterprise networking
environments in which this solution is expected to operate. It then discusses
existing and proposed mechansisms for hosts to select the source address applied 
to packets. Finally, it looks at the requirements for routing that are needed 
to support these enterprise network scenarios and the mechanisms by which hosts
are expected to select source addresses dynamically based on network state.
</t>

</section>


<section anchor="sec_enterprise_req" title="Enterprise Multihoming Requirements">


<section anchor="sec_simple_scenario" title="Simple ISP Connectivity with Connected SERs">
<t>We start by looking at a scenario where a site has connections to two ISPs,
as shown in <xref target="fig_simple_scenario"/>.
The site is assigned the prefix 2001:db8:0:a000::/52 by ISP-A 
and prefix 2001:db8:0:b000::/52 by ISP-B. 
We consider three hosts in the site.  H31 and H32 are on a LAN  
that has been assigned subnets 2001:db8:0:a010::/64 and 
2001:db8:0:b010::/64.  H31 has been assigned the addresses 
2001:db8:0:a010::31 and 2001:db8:0:b010::31.  H32 has been assigned 
2001:db8:0:a010::32 and 2001:db8:0:b010::32.
H41 is on a different subnet that has been 
assigned 2001:db8:0:a020::/64 and 2001:db8:0:b020::/64.  
</t>



<figure anchor="fig_simple_scenario" title="Simple ISP Connectivity 
With Connected SERs" align="center">
<artwork align="center"><![CDATA[
                                        2001:db8:0:a010::101   H101
                                                                 |
                                                                 |
2001:db8:0:a010::31                                          --------
2001:db8:0:b010::31                            ,-----.      /        \
                   +--+   +--+       +----+  ,'       `.   :          :
               +---|R1|---|R4|---+---|SERa|-+   ISP-A   +--+--        :
          H31--+   +--+   +--+   |   +----+  `.       ,'   :          :
               |                 |             `-----'     : Internet :
               |                 |                         :          :
               |                 |                         :          :
               |                 |                         :          :
               |                 |             ,-----.     :          :
          H32--+   +--+          |   +----+  ,'       `.   :          :
               +---|R2|----------+---|SERb|-+   ISP-B   +--+--        :
                   +--+          |   +----+  `.       ,'   :          :
                                 |             `-----'     :          :
                                 |                         :          :
                   +--+  +--+  +--+                         \        /
          H41------|R3|--|R5|--|R6|                          --------  
                   +--+  +--+  +--+ 

2001:db8:0:a020::41 
2001:db8:0:b020::41

]]></artwork>
</figure>

<t>We refer to a router that connects the site to an ISP as a site edge router(SER).
Several other routers provide connectivity among the internal hosts 
(H31, H32, and H41), as well as connecting the internal 
hosts to the Internet through SERa and SERb.  In this example 
SERa and SERb share a direct connection to each other.  
In <xref target="sec_simple_not_dir_conn"/>,
we consider a scenario where this is not the case.
</t>

<t> For the moment, we assume that the hosts are able to make good choices about 
which source addresses through some mechansism that doesn't involve the routers in the site
network.  Here, we focus on primary task of the routed site network, which is to get packets
efficiently to their destinations, while sending a packet to the ISP that assigned the prefix
that matches the source address of the packet.  In 
<xref target="sec_host_mechanisms"/>, we examine what role the routed network
may play in helping hosts make good choices about source addresses for packets.
</t>

<t>  With this solution, routers will need form of Source Address Dependent Routing, 
which will be new funtionality.  It would be useful if an enterprise site does not 
need to upgrade all routers to support the new SADR functionality in order to support 
PA multi-homing.  We consider if this is possible and what are the tradeoffs of not 
having all routers in the site support SADR functionality.
</t>

<t>In the topology in <xref target="fig_simple_scenario"/>, it is possible to 
support PA multihoming with only SERa and SERb being capable of SADR.  The other routers 
can continue to forward based only on destination address, and exchange routes that 
only consider destination address.  In this scenario, SERa and SERb communicate source-scoped
routing information across their shared connection.  When SERa receives a packet 
with a source address matching prefix 2001:db8:0:b000::/52 , 
it forwards the packet to SERb, which forwards it on
the uplink to ISP-B.  The analogous behavious holds for traffic that SERb recieves with a source
address matching prefix 2001:db8:0:a000::/52.   
</t>

<t>In <xref target="fig_simple_scenario"/>, when only SERa and SERb are capable of 
source address dependent routing, PA multi-homing will work.  However, the paths over which 
the packets are sent will generally not be the shortest paths.  The forwarding paths will 
generally be more efficient as more routers are capable of SADR.  For example, if R4, R2, and R6
are upgraded to support SADR, then can exchange source-scoped routes with SERa and SERb. 
They will thne know to send traffic with a 
source address matching prefix 2001:db8:0:b000::/52 directly to SERb, without sending
it to SERa first.
</t> 

</section>

<section anchor="sec_simple_not_dir_conn" title="Simple ISP Connectivity Where
SERs Are Not Directly Connected">

<t>In <xref target="fig_simple_not_dir_conn"/>, we modify the topology slightly 
by inserting R7, so that SERa and SERb are no longer directly connected.  With
this topology, it is not enough to just enable SADR routing on SERa and SERb to support
PA multi-homing.  There are two solutions to ways to enable PA multihoming in this 
topology.
</t> 

<figure anchor="fig_simple_not_dir_conn" title="Simple ISP Connectivity Where
SERs Are Not Directly Connected" align="center">
<artwork align="center"><![CDATA[
                                        2001:db8:0:1234::101    H101
                                                                 |
                                                                 |
2001:db8:0:a010::31                                          --------
2001:db8:0:b010::31                            ,-----.      /        \
                   +--+   +--+       +----+  ,'       `.   :          :
               +---|R1|---|R4|---+---|SERa|-+   ISP-A   +--+--        :
          H31--+   +--+   +--+   |   +----+  `.       ,'   :          :
               |                 |             `-----'     : Internet :
               |               +--+                        :          :
               |               |R7|                        :          :
               |               +--+                        :          :
               |                 |             ,-----.     :          :
          H32--+   +--+          |   +----+  ,'       `.   :          :
               +---|R2|----------+---|SERb|-+   ISP-B   +--+--        :
                   +--+          |   +----+  `.       ,'   :          :
                                 |             `-----'     :          :
                                 |                         :          :
                   +--+  +--+  +--+                         \        /
          H41------|R3|--|R5|--|R6|                          --------  
                   +--+  +--+  +--+                              |
                                                                 | 
2001:db8:0:a020::41                     2001:db8:0:5678::501    H501
2001:db8:0:b020::41

]]></artwork>
</figure>

<t> One option is to effectively modify the topology by creating a logical tunnel between 
SERa and SERb, using GRE for example.  Although SERa and SERb are not directly connected physically
in this topology, they can be directly connected logically by a tunnel.
</t> 

<t> The other option is to enable SADR functionality on R7.  In this way, R7 will
exchange source-scoped routes with SERa and SERb, making the three routers act as a
single SADR domain.  This illustrates the basic principle that the minimum requirement 
for the routed site network to 
support PA multi-homing is having all of the site exit routers be part of a 
connected SADR domain.  Extending the connected SADR domain beyond that point 
can produce more efficient forwarding paths.
</t> 

</section>

<section anchor="sec_network_operator_expectations" title="Enterprise Network Operator Expectations">

<t> Before considering a more complex scenario, let's look in more detail at the
reasonably simple multihoming scenario in <xref target="fig_simple_not_dir_conn"/> to understand 
what can reasonably be expected from this solution.  As a general guiding principle,
we assume an enterprise network operator will expect a multihomed network to behave as 
close as to a single-homed network as possible.  So a solution that meets those expectations 
where possible is a good thing.
</t> 

<t> For traffic between internal hosts and traffic from outside the site to 
internal hosts, an enterprise network operator would expect there to be 
no visible change in the path taken by this traffic, 
since this traffic does not need to be routed in a way that depends on source address.
It is also reasonable to expect that internal hosts should be able to communicate
with each other using either of their source addresses without restriction.
For example, H31 should be able to communicate with H41 using a packet 
with S=2001:db8:0:a010::31, D=2001:db8:0:b010::41, regardless of the state of 
uplink to ISP-B.  
</t> 

<t>These goals can be accomplished by having all of the routers in the network 
continue to originate normal unscoped destination routes
for their connected networks.  If we can arrange so that these unscoped 
destination routes get used for forwarding this traffic, then we will have accomplished
the goal of keeping forwarding of traffic destined for internal hosts, unaffected by 
the multihoming solution.  
</t>

<t> For traffic destined for external hosts, it is reasonable to expect
that traffic with an source adddress from the prefix assigned by ISP-A to
follow the path to that the traffic would follow if there is no connection 
to ISP-B.  This can be accomplished by having SERa originate a source-scoped 
route of the form (S=2001:db8:0:a000::/52, D=::/0) .  If all of the routers in the
site support SADR, then the path of traffic exiting via ISP-A can match that
expectation.   If some routers don't support SADR, then it is reasonable 
to expect that the path for traffic exiting via ISP-A may be different within the
site.  This is a tradeoff that the enterprise network operator may decide to make.
</t> 

<t> It is important to understand how this multihoming solution behaves 
when an uplink to one of the ISPs fails. To simplify this discussion, 
we assume that all routers in the site support SADR.  
We first start by looking at how the network operates when the uplinks to 
both ISP-A and ISP-B are functioning properly.  SERa originates a source-scoped 
route of the form (S=2001:db8:0:a000::/52, D=::/0), and 
SERb is originates a source-scoped 
route of the form (S=2001:db8:0:b000::/52, D=::/0).  These routes 
are distributed through the routers in the site, 
and they establish within the routers two set of forwarding paths for 
traffic leaving the site.  One set of forwarding paths is for packets
with source address in 2001:db8:0:a000::/52.  The other set of forwarding paths is 
for packets with source address in 2001:db8:0:b000::/52.  The 
normal destination routes which are not scoped to these two source
prefixes play no role in the forwarding. 
Whether a packet exits the site via SERa or via SERb is completely 
determined by the source address applied to the packet by the host. 
So for example, when host H31 sends a packet to host H101 with
(S=2001:db8:0:a010::31, D=2001:db8:0:1234::101), the packet will 
only be sent out the link from SERa to ISP-A.  
</t> 

<t> Now consider what happens when the uplink from 
SERa to ISP-A fails.  The only way for the packets from 
H31 to reach H101 is for H31 to start using the source address
for ISP-B. H31 needs to send the following packet: 
(S=2001:db8:0:b010::31, D=2001:db8:0:1234::101).  As far as 
the forwarding functionality of the site network is concerned,
there is no reason for SERa to stop originating the route of the 
form (S=2001:db8:0:a000::/52, D=::/0) when the uplink
to ISP-A fails, and there is no reason to change the 
forwarding so that a packet 
with source address 2001:db8:0:a010::31 is sent to ISP-B.  
</t> 

<t> This behavior is very different from the behavior that occurs 
with site multihoming using PI addresses or with PA addresses using NAT.  
In these other multi-homing solutions, hosts do not need to 
react to network failures several hops away in order to regain 
internet access.  Instead, a host can be largely unaware of the failure
of an uplink to an ISP.  When multihoming with PA addresses and NAT, 
existing sessions generally need to be re-established after a failure since the 
external host will receive packets from the internal host with a new source 
address.  However, new sessions can be established without any 
action on the part of the hosts. 
</t> 

<t> Another example where the behavior of this multihoming solution
differs significantly from that of multihoming with PI address or with PA 
addresses using NAT is in the ability of the enterprise network operator 
to route traffic over different ISPs based on destination address.  We 
still consider the fairly simple network of 
<xref target="fig_simple_not_dir_conn"/> and assume that uplinks
to both ISPs are functioning.  Assume that the site is multihomed using
PA addresses and NAT, and that SERa and SERb each originate a normal destination 
route for D=::/0, with the route origination dependent on the state of the 
uplink to the respective ISP.
</t>

<t> Now suppose it is observed that an important application running 
between internal hosts and external host H101 experience much better performance 
when the traffic passes through ISP-A
(perhaps because ISP-A provides lower latency to H101.)
When multihoming this site with PI addresses or 
with PA addresses and NAT, the enterprise network operator
can configure SERa to originate into the site network a normal destination route for 
D=2001:db8:0:1234::/64 (the destination prefix to reach H101) that 
depends on the state of the uplink to ISP-A.  When the link to ISP-A is 
functioning, the destination route D=2001:db8:0:1234::/64 will be originated 
by SERa, so traffic from all hosts will use ISP-A to reach H101 based on the 
longest destination prefix match in the route lookup. 
</t>

<t> Implementing the same routing policy is more difficult with the PA multihoming 
solution described in this document since it doesn't use NAT.  By design, the only way to control
where a packet exits this network is by setting the source address of the packet.  Since the 
network cannot modify the source address without NAT, the host must set it.
To implement this routing policy, each host needs to use the source address from the prefix assigned
by ISP-A to send traffic destined for H101.  Mechansisms have been proposed to 
allow hosts to choose the source address for packets in a fine grained manner.  We will discuss 
these proposals in <xref target="sec_host_mechanisms"/>.  However, 
interacting with host operating systems in some manner to ensure a particular source address is chosen
for a particular destination prefix is not what an enterprise network administrator would expect
to have to do to implement this routing policy.
</t>
</section>

<section anchor="sec_more_complex_isp_connectivity" title="More complex ISP connectivity">

<t>The previous sections considered two variations of a simple multihoming scenario where
the site is connected to two ISPs offering only internet connectivity.  It is likely that 
many actual enterprise multihoming scenarios will be similar to this simple example.
However, there are more complex multihoming scenarios that we would like this solution 
to address as well.   
</t>

<t>It is fairly common for an ISP to offer a service in addition
to internet access over the same uplink.  Two variation of this are reflected in 
<xref target="fig_isp_service"/>.  In addition to internet access, 
ISP-A offers a service which requires the site
to access host H51 at 2001:db8:0:5555::51.  The site has 
a single physical and logical connection with ISP-A, and 
ISP-A only allows access to H51 over that connection.
So when H32 needs to access the service at H51
it needs to send packets with (S=2001:db8:0:a010::32, D=2001:db8:0:5555::51)
and those packets need to be forward out the link from SERa to ISP-A.  
</t>


<figure anchor="fig_isp_service" title="Internet access and services offered
 by ISP-A and ISP-B " align="center">
<artwork align="center"><![CDATA[
                                        2001:db8:0:1234::101    H101
                                                                 |
                                                                 |
2001:db8:0:a010::31                                          --------
2001:db8:0:b010::31                            ,-----.      /        \
                   +--+   +--+       +----+  ,'       `.   :          :
               +---|R1|---|R4|---+---|SERa|-+   ISP-A   +--+--        :
          H31--+   +--+   +--+   |   +----+  `.       ,'   :          :
               |                 |             `-----'     : Internet :
               |                 |                |        :          :
               |                 |               H51       :          :
               |                 |     2001:db8:0:5555::51 :          :
               |               +--+                        :          :
               |               |R7|                        :          :
               |               +--+                        :          :
               |                 |                         :          :
               |                 |             ,-----.     :          :
          H32--+   +--+          |  +-----+  ,'       `.   :          :
               +---|R2|-----+----+--|SERb1|-+   ISP-B   +--+--        :
                   +--+     |       +-----+  `.       ,'   :          :
                          +--+                 `--|--'     :          :
 2001:db8:0:a010::32      |R8|                    |         \        /
                          +--+                 ,--|--.       --------   
                            |       +-----+  ,'       `.         |      
                            +-------|SERb2|-+   ISP-B   |        |        
                            |       +-----+  `.       ,'       H501         
                            |                  `-----'  2001:db8:0:5678             
                            |                     |               ::501
                    +--+  +--+                   H61         
           H41------|R3|--|R5|           2001:db8:0:6666::61            
                    +--+  +--+                                     
                                         
2001:db8:0:a020::41                                                 
2001:db8:0:b020::41
]]></artwork>
</figure>


<t> ISP-B illustrates a variation on this scenario.  In addition to 
internet access, ISP-B also offers a service which requires the 
site to access host H61.  The site has two connections to two different
parts of ISP-B (shown as SERb1 and SERb2 in <xref target="fig_isp_service"/>).
ISP-B expects internet traffic to use the uplink from SERb1, while it 
expects it expects traffic destined for the service at H61 to use the 
uplink from SERb2.  For either uplink, ISP-B expects the ingress 
traffic to have a source address matching the prefix it assigned to 
the site, 2001:db8:0:b000::/52.  
</t>

<t> As discussed before, we rely completely on the internal host
to set the source address of the packet properly.  In the case of a 
packet sent by H31 to access the service in ISP-B at H61, we expect the 
packet to have the following addresses: (S=2001:db8:0:b010::31, D=2001:db8:0:6666::61).  
The routed network has two potential ways of distributing routes so that 
this packet exits the site on the uplink at SERb2.
</t>

<t> We could just rely on normal destination routes, without using source-prefix scoped routes.
If we have SERb2 originate a normal unscoped destination route for D=2001:db8:0:6666::/64,
the packets from H31 to H61 will exit the site at SERb2 as desired.  We should not have to worry 
about SERa needing to originate the same route, because ISP-B should choose a globally unique 
prefix for the service at H61.  
</t>

<t> The alternative is to have SERb2 originate a source-prefix-scoped destination route of the 
form (S=2001:db8:0:b000::/52, D=2001:db8:0:6666::/64).  From a forwarding point of view, the use 
of the source-prefix-scoped destination route would result in traffic with source addresses corresponding 
only to ISP-B being sent to SERb2. Instead, the use 
of the unscoped destination route would result in traffic with source addresses corresponding 
to ISP-A and ISP-B being sent to SERb2, as long as the destination address matches the destination prefix.
It seems like either forwarding behavior would be acceptable.  
</t>

<t> However, from the point of view of the enterprise network administrator trying to configure,
maintaim, and trouble-shoot 
this multihoming solution, it seems much clearer to have SERb2 originate the source-prefix-scoped
destination route correspond to the service offered by ISP-B.
In this way, all of the traffic leaving the site is determined by the source-prefix-scoped routes,
and all of the traffic within the site or arriving from external hosts is determined by 
the unscoped destination routes.  Therefore, for this multihoming solution we choose to originate 
source-prefix-scoped routes for all traffic leaving the site.
</t>

</section>

<section anchor="sec_isps_and_pa_prefixes" title="ISPs and Provider-Assigned Prefixes">
<t> While we expect that most site multihoming involves connecting to only two ISPs,
this solution allows for conections to an arbitrary number of ISPs to be supported.
However, when evaluating scalable implementations of the solution, it would be reasonable to assume
that the maximum number of ISPs that a site would connect to is five.
</t>

<t> It is also useful to note that the prefixes assigned to the site by different ISPs
will not overlap.  This must be the case , since the provider-assigned 
addresses have to be globablly unique.
</t>
</section>

<section anchor="sec_simpler_topologies" title="Simplified Topologies">
<t> The topologies of many enterprise sites using this multihoming solution may 
in practice be simpler than the examples that we have used. The topology
in  <xref target="fig_simple_scenario"/> could be further simplified by having 
all hosts directly connected to the LAN connecting the two site exit routers, 
SERa and SERb.  The topology could also be simplified by having the
uplinks to ISP-A and ISP-B both connected to the same site exit router.
However, it is the aim of this draft to provide a solution that applies to 
a broad a range of enterprise site network topologies, so 
this draft focuses on providing a solution to the more general case.
The simplified cases will also be supported by this solution, and there
may even be optimizations that can be made for simplified cases. This solution 
however needs to support more complex topologies.
</t>

<t>
We are starting with the basic assumption that enterprise site networks can be quite 
complex from a routing perspective. However, even a complex site network 
can be multihomed to different ISPs with PA addreses using IPv4 and NAT. 
It is not reasonable to expect an enterprise network operator to change the 
routing topology of the site in order to deploy IPv6.
</t>
</section>

</section>

<section anchor="sec_method" title="Generating
 Source-Prefix-Scoped Forwarding Tables">
 <t> So far we have described in general terms how the routers in this solution that are capable 
 of Source Address Dependent Routing will forward traffic using both normal unscoped
 destination routes and source-prefix-scoped destination routes.  Here we give a precise method 
 for generating a source-prefix-scoped forwarding table on a router that supports SADR.
</t>
 
<t> 
<list>

<t>
1) Compute the next-hops for the source-prefix-scoped destination prefixes using 
only routers in the connected SADR domain. These are the initial source-prefix-scoped
forwarding table entries.
</t>

<t>
2) Compute the next-hops for the unscoped destination prefixes using all routers
in the IGP.  This is the unscoped forwarding table.
</t>

<t>
3) Augment each source-prefix-scoped forwarding table with unscoped 
forwarding table entries based on the following rule. If the destination 
prefix of the unscoped forwarding entry exactly matches the destination 
prefix of an existing source-prefix-scoped forwarding entry (including 
destination prefix length), then do not add the unscoped forwarding 
entry. If the destination prefix does NOT match an existing enty, then 
add the entry to the source-prefix-scoped forwarding table. 
</t>

</list>
</t>
 
<t>
The forward tables produced by this process are used in the following way to forward packets.

<list>

<t>
1) If the source address of the packet matches one of the source 
prefixes, then look up the destination address of the packet in the 
corresponding source-prefix-scoped forwarding table to determine the 
next-hop for the packet. 
</t>

<t>
2) If the source address of the packet does NOT match one of the source 
prefixes, then look up the destination address of the packet in unscoped 
forwarding table to determine the next-hop for the packet. 
</t>

</list>
</t>

<t> The following example illustrates how this process is used to create
a forwarding table for each provider-assigned source prefix.  We consider the
multihomed site network in <xref target="fig_isp_service"/>. Initially we assume
that all of the routers in the site network support SADR. 
<xref target="fig_routes_originated"/> shows the routes that are originated by the routers 
in the site network.
</t>

<figure anchor="fig_routes_originated" title="Routes Originated by Routers in the Site Network"
 align="center">
<artwork align="left"><![CDATA[
Routes originated by SERa:
(S=2001:db8:0:a000::/52, D=2001:db8:0:5555/64)
(S=2001:db8:0:a000::/52, D=::/0)
(D=2001:db8:0:5555::/64)
(D=::/0)

Routes originated by SERb1:
(S=2001:db8:0:b000::/52, D=::/0)
(D=::/0)

Routes originated by SERb2:
(S=2001:db8:0:b000::/52, D=2001:db8:0:6666::/64)
(D=2001:db8:0:6666::/64)

Routes originated by R1:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R2:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R3:
(D=2001:db8:0:a020::/64)
(D=2001:db8:0:b020::/64)
]]></artwork>
</figure>

<t> Each SER originates destination routes which are scoped to the source prefix assigned
by the ISP that the SER connects to.  Note that the SERs also originate the corresponding 
unscoped destination route.  This is not needed when all of the routers in the site support
SADR.  However, it is required when some routers do not support SADR.  This will be discussed 
in more detail later.
</t>

<t> We focus on how R8 constructs its source-prefix-scoped forwarding tables
from these route advertisements. R8 computes the next hops for destination routes which are scoped to the 
source prefix 2001:db8:0:a000::/52. The results are shown in the first table 
in <xref target="fig_forwarding_entries"/>.
(In this example, the next hops are computed assuming that all links have the same metric.)
Then, R8 computes the next hops 
for destination routes which are scoped to the 
source prefix 2001:db8:0:b000::/52. The results are shown in the second table 
in <xref target="fig_forwarding_entries"/> .
Finally, R8 computes the next hops for the unscoped destination
prefixes.  The results are shown in the third table in <xref target="fig_forwarding_entries"/>.
</t>

<figure anchor="fig_forwarding_entries" title="Forwarding Entries Computed at R8"
 align="center">
<artwork align="left"><![CDATA[
forwarding entries scoped to 
source prefix = 2001:db8:0:a000::/52
============================================
D=2001:db8:0:5555/64      NH=R7
D=::/0                    NH=R7

forwarding entries scoped to 
source prefix = 2001:db8:0:b000::/52
============================================
D=2001:db8:0:6666/64      NH=SERb2
D=::/0                    NH=SERb1

unscoped forwarding entries
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=SERb1
]]></artwork>
</figure>

<t> The final step is for R8 to augment the source-prefix-scoped 
forwarding entries with unscoped forwarding entries.  
If an unscoped forwarding entry has the exact same destination prefix 
as an source-prefix-scoped forwarding entry (including destination prefix length), 
then the source-prefix-scoped forwarding entry wins.
</t>

<t> As as an example of how the source scoped forwarding entries are augmented
with unscoped forwarding entries, we consider  how the two entries in the 
first table in <xref target="fig_forwarding_entries"/> 
(the table for source prefix = 2001:db8:0:a000::/52)
are augmented with entries from the third table in <xref target="fig_forwarding_entries"/>
(the table of unscoped forwarding entries).  The first four unscoped forwarding 
entries (D=2001:db8:0:a010::/64, D=2001:db8:0:b010::/64, D=2001:db8:0:a020::/64, 
and D=2001:db8:0:b020::/64) are not an exact match for any of the existing entries in the
forwarding table for source prefix 2001:db8:0:a000::/52.  Therefore,  
these four entries are added to the final forwarding table for source prefix 2001:db8:0:a000::/52.  
The result of adding these entries is reflected in first four entries the first 
table in <xref target="fig_forwarding_tables"/>.  
</t>

<t> The next unscoped forwarding table entry is for D=2001:db8:0:5555::/64.  This entry
is an exact match for the existing entry in the
forwarding table for source prefix 2001:db8:0:a000::/52.  Therefore, we do not replace 
the existing entry with the entry from the unscoped forwarding table.  This is reflected 
in the fifth entry in the first table in <xref target="fig_forwarding_tables"/>.  (Note
that since both scoped and unscoped entries have R7 as the next hop, the result of 
applying this rule is not visible.)
</t>

<t> The next unscoped forwarding table entry is for D=2001:db8:0:6666::/64. This entry is not an exact match 
for any existing entries in the forwarding table for source prefix 
2001:db8:0:a000::/52. Therefore, we add this entry. This is reflected 
in the sixth entry in the first table in <xref 
target="fig_forwarding_tables"/>. 
</t>

<t> The next unscoped forwarding table entry is for D=::/0. This entry is 
an exact match for the existing entry in the forwarding table for source 
prefix 2001:db8:0:a000::/52. Therefore, we do not overwrite the 
existing source-prefix-scoped entry, as can be seen in the last 
entry in the first table in <xref target="fig_forwarding_tables"/>.
</t> 

<figure anchor="fig_forwarding_tables" title="Complete Forwarding Tables Computed at R8"
 align="center">
<artwork align="left"><![CDATA[

if source address matches 2001:db8:0:a000::/52
then use this forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=R7

else if source address matches 2001:db8:0:b000::/52
then use this forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=SERb1

else use this forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R2
D=2001:db8:0:b010::/64    NH=R2
D=2001:db8:0:a020::/64    NH=R5
D=2001:db8:0:b020::/64    NH=R5
D=2001:db8:0:5555::/64    NH=R7
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=SERb1
]]></artwork>
</figure>

<t> The forwarding tables produced by this process at R8 have the desired properties.
A packet with a source address in 2001:db8:0:a000::/52 will be forwarded based on the 
first table in <xref target="fig_forwarding_tables"/>.
If the packet is destined for the internet at large or the service at
D=2001:db8:0:5555/64, it will be sent to R7 in the direction of SERa.
If the packet is destined for an internal host, then the first four entries will send
it to R2 or R5 as expected.  Note that if this packet has a destination address corresponding
to the service offered by ISP-B (D=2001:db8:0:5555::/64), then it will get 
forwarded to SERb2.  It will be dropped by SERb2 or by ISP-B, since it the packet has a 
source address that was not assigned by ISP-B.  However, this is expected behavior.  In order
to use the service offered by ISP-B, the host needs to originate the packet with a source 
address assigned by ISP-B.  
</t> 

<t> In this example, a packet with a source address that doesn't match 2001:db8:0:a000::/52 or 
2001:db8:0:b000::/52 must have originated from an external host.  Such a packet will use the unscoped 
forwarding table (the last table in <xref target="fig_forwarding_tables"/>).  These packets will 
flow exactly as they would in absence of multihoming.  
</t> 

<t> We can also modify this example to illustrate how it supports deployments where 
not all routers in the site support SADR.  Continuing with the topology shown in 
<xref target="fig_isp_service"/>, suppose that R3 and R5 do not support SADR.
Instead they are only capable of understanding unscoped route advertisements.  
The SADR routers in the network will still originate the routes 
shown in <xref target="fig_routes_originated"/>.  However, R3 and R5 will only 
understand the unscoped routes as shown in <xref target="fig_routes_understood_by_non_SADR"/>.
</t> 

<figure anchor="fig_routes_understood_by_non_SADR" title="Routes Advertisements Understood by Routers
that do no Support SADR"
 align="center">
<artwork align="left"><![CDATA[
Routes originated by SERa:
(D=2001:db8:0:5555::/64)
(D=::/0)

Routes originated by SERb1:
(D=::/0)

Routes originated by SERb2:
(D=2001:db8:0:6666::/64)

Routes originated by R1:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R2:
(D=2001:db8:0:a010::/64)
(D=2001:db8:0:b010::/64)

Routes originated by R3:
(D=2001:db8:0:a020::/64)
(D=2001:db8:0:b020::/64)
]]></artwork>
</figure>

<t> With these unscoped route advertisements, R5 will produce the forwarding table shown in 
<xref target="fig_R5_forwarding_table"/>.
</t> 

<figure anchor="fig_R5_forwarding_table" title="Forwarding Table For R5, Which Doesn't 
Understand Source-Prefix-Scoped Routes"
 align="center">
<artwork align="left"><![CDATA[
forwarding table
============================================
D=2001:db8:0:a010::/64    NH=R8
D=2001:db8:0:b010::/64    NH=R8
D=2001:db8:0:a020::/64    NH=R3
D=2001:db8:0:b020::/64    NH=R3
D=2001:db8:0:5555::/64    NH=R8
D=2001:db8:0:6666::/64    NH=SERb2
D=::/0                    NH=R8
]]></artwork>
</figure>

<t> Any traffic that needs to exit the site will eventually hit a SADR-capable
router.  Once that traffic enters the SADR-capable domain, then it will not leave that 
domain until it exits the site.  This property is required in order to guarantee that 
there will not be routing loops involving SADR-capable and non-SADR-capable routers.
</t> 

<t> Note that the mechanism described here for converting source-prefix-scoped destination prefix routing
advertisements into forwarding state is somewhat different from that proposed in
<xref target="I-D.ietf-rtgwg-dst-src-routing"/>.  The method described in this document is
intended to be easy to understand for network enterprise operators while at the same time 
being functionally correct.  Another difference is that the method in this document 
assumes that source prefix will not overlap.  Other differencse between the two approaches 
still need to be understood and reconciled.
</t> 

</section>

<section anchor="sec_host_mechanisms" title="Mechanisms For Hosts To Choose Good Source Addresses In A Multihomed Site">
<t> Until this point, we have made the assumption that hosts are able to choose the correct 
source address using some unspecified mechanism.  This has allowed us to just focus on 
what the routers in a multihomed site network need to do in order to forward packets 
to the correct ISP based on source address.  Now we look at possible mechanisms for hosts 
to choose the correct source address.  We also look at what role, if any, the routers may play 
in providing information that helps hosts to choose source addresses.  
</t>

<t> Any host that needs to be able to send traffic using the uplinks to a given ISP is expected to be
configured with an address from the prefix assigned by that ISP.  The host will 
control which ISP is used for its traffic by selecting one of the addresses configured on 
the host as the source address for outgoing traffic.  It is the responsibility of the site
network to ensure that a packet with the source address from an ISP is not sent on an uplink to 
that ISP.
</t>

<t> If all of the ISP uplinks are working, the choice of source address by the host 
may be driven by the desire to load share across ISP uplinks, or it may be driven by the desire to 
take advantage of certain properties of a particular uplink or ISP.  If any of the ISP uplinks 
is not working, then the choice of source address by the host can determine if packets get dropped.   
</t>

<t> How a host should make good decisions about source address selection in a multihomed
site is not a solved problem.  We do not attempt to solve this problem in this document. 
Instead we discuss the current state of affairs with respect to standardized solutions and
implementation of those solutions.  We also look at proposed solutions for this problem.
</t>

<t> An external host initiating communication with a host internal to a PA multihomed site
will need to know multiple addresses for that host in order to communicate with it using
different ISPs to the multihomed site. These addresses are typically learned through DNS.  
(For simplicity, we assume that the external host is single-homed.)
The external host chooses the ISP that will be used at the remote multihomed site by setting
the destination address on the packets it transmits. For a sessions 
originated from an external host to an internal host, the choice of source address
used by the internal host is simple.  The internal host has no choice but to use the destination 
address in the received packet as the source address of the transmitted packet.   
</t>

<t> For a session originated by a host internal to the multi-homed site, the decision of what source 
address to select is more complicated. We consider three main methods for hosts to get information about the 
network.  The two proactive methods are Neighbor Discovery Router Advertisements and DHCPv6.  The one 
reactive method we consider is ICMPv6.  Note that we are explicitly
excluding the possibility of having hosts participate in or even listen directly
to routing protocol advertisements.
</t>

<t> First we look at how a host is currently expected to select the source and destination address 
with which it sends a packet.  
</t>

<section anchor="sec_host_address_selection_algo" title="Source Address Selection Algorithm on Hosts">
<t> 
<xref target="RFC6724"/> defines the algorithms that hosts are expected to use to select source and destination 
addresses for packets.  It defines an algorithm for selecting a source address and a separate algorithm for selecting
a destination address.  Both of these algorithms depend on a policy table. <xref target="RFC6724"/> defines a 
default policy which produces certain behavior.  
</t>

<t> The rules in the two algorithms in <xref target="RFC6724"/> depend on many different properties of addresses.
While these are needed for understanding how a host should choose addresses in an arbitary environment, most of 
the rules are not relevant for understanding how a host should choose among mulitple source addresses when sending 
a packet to a remote host. Returning to the example in <xref target="fig_isp_service"/>, we look 
at what the default algorithms in <xref target="RFC6724"/> say about the source address that 
internal host H31 should use to send traffic to external host H101, somewhere on the Internet.
Let's look at what rules in <xref target="RFC6724"/> are actually used by H31 in this case.
</t>

<t> There is no choice to be made with respect to destination address.
H31 needs to send a packet with D=2001:db8:0:1234::101 in order to reach H101.    
So H31 have to choose between using S=2001:db8:0:a010::31 or S=2001:db8:0:b010::31 as the source 
address for this packet.  We go through the rules for source address selection in 
Section 5 of <xref target="RFC6724"/>.  Rule 1 (Prefer same address) is not useful 
to break the tie between source addresses,
because neither the candidate source addresses equals the destination address.
Rule 2 (Prefer appropriate scope) is also not used in this scenario,  
because both source addresses and the
destination address have global scope.  
</t>

<t>
Rule 3 (Avoid deprecated addresses) applies to an address that has been
autoconfigured by a host using stateless address autoconfiguration as 
defined in <xref target="RFC4862"/>. An address autoconfigured by a 
host has a preferred lifetime and a valid lifetime.  The address is 
preferred until the preferred lifetime expires, after which it 
becomes deprecated.  A deprecated address can still be used, but 
it is better to use a preferred adddress.  When the valid lifetime 
expires, the address cannot be used at all.  The preferred and 
valid lifetimes for an autoconfigured address are set based on the 
corresponding lifetimes in the Prefix Information Option  in 
Neighbor Discovery Router Advertisements.  So a possible tool to 
control source address selection in this scenario would be to a host to make 
an address deprecated (or invalid) by having routers on that link, 
R1 and R2 in <xref target="fig_isp_service"/>, 
send Prefix Information Option messages with the preferred (or valid) lifetime for the source 
prefix to be discouraged (or prohibited) set to zero.  
This is a rather blunt tool, because it discourges or prohibits the 
use of that source prefix for all destinations.  However, it may be useful
in some scenarios.  In the list of relevant source address selection 
rules below, we have created a rule 0 to capture the possibility of prohibiting
the use of a source address by making it invalid via Prefix Information Option messages.  
</t>

<t>Rule 4 (Avoid home addresses) does not apply here because we are not 
considering Mobile IP.  Rule 5 (Prefer outgoing interface) is not useful 
in this scenario, because both source addresses are assigned
to the same interface.  Rule 5.5 is also 
not useful in this scenario, because
both R1 and R2 will advertise both source prefixes.   
</t>

<t>Rule 6 (Prefer matching label) refers to the Label value determined for 
each source and destination prefix as a result of applying the policy table to 
the prefix.  With the default policy table defined in 
Section 2.1 of <xref target="RFC6724"/>, Label(2001:db8:0:a010::31) = 5, 
Label(2001:db8:0:b010::31) = 5,  and Label(2001:db8:0:1234::101) = 5.  So with
the default policy, Rule 6 does not break the tie.  However, the algorithms
in <xref target="RFC6724"/> are defined in such as way that non-default address selection policy
tables can be used.  
<xref target="RFC7078"/> defines a way to distribute a non-default
address selection policy table to hosts using DHCPv6.  So even though the application 
of rule 6 to this scenario using the default policy table is not useful, rule 6
may still be a useful tool.
</t>

<t> Rule 7 (Prefer temporary addresses) has to do
 with the technique described in <xref target="RFC4941"/> to periodically 
 randomize the interface portion of an IPv6 address that
 has been generated using stateless
 address autoconfiguration.  In general, if H31 were using this technique, it would 
 use it for both source addresses, for example creating temporary addresses 
2001:db8:0:a010:2839:9938:ab58:830f and 2001:db8:0:b010:4838:f483:8384:3208, in addition 
to 2001:db8:0:a010::31 and 2001:db8:0:b010::31.  So this rule would prefer the two 
temporary addresses, but it would not break the tie between the two source prefixes 
from ISP-A and ISP-B.  
</t>

<t> So we can see that of the 7 source selection address rules from <xref target="RFC6724"/>, 
only a few actually apply to our basic site multihoming scenario.  The rules that are 
relevant to this scenario are summarized below.  
</t>

<t>
<list>
<t>
Rule 0: Only uses valid addresses.  
</t>
<t>
Rule 3: Avoid deprecated addresses.
</t>
<t>
Rule 6: Prefer matching label.
</t>
</list>
</t>

<t> The two main methods that we consider for controlling the source address selection through the three
relevant rules above are Neighbor Discovery Router Advertisment messages and DHCPv6. 
</t>

<t>We also consider a possible role for ICMPv6 for getting 
traffic-driven feedback from the network. With the source address 
selection algorithm discussed above, the goal is to choose the correct 
source address on the first try, before any traffic is sent. However, 
another strategy is to choose a source address, send the packet, get 
feedback from the network about whether or not the source address is 
correct, and try another source address if it is not. 
</t>

<t> We consider two common scenarios where a host needs to select the correct source address. 
The first is when both uplinks are working.  The second is when one uplink has
failed.
</t>
</section>

<section anchor="sec_both_uplinks_working" title="Selecting Source Address When Both Uplinks Are Working">
<t> Again we return to the topology in <xref target="fig_isp_service"/>. 
Suppose that that site admininistrator wants to implement a policy by 
which all hosts need to use ISP-A to reach H01 at D=2001:db8:0:1234::101.
So for example, H31 needs to select S=2001:db8:0:a010::31.
</t>

<section anchor="sec_both_working_dhcpv6" title="Distributing Address Selection Policy Table with DHCPv6">
<t> This policy can be implemented by using DHCPv6 to distribute an address selection policy table 
that assigns the same label to destination address that match 2001:db8:0:1234::/64 as it does to source 
addresses that match 2001:db8:0:a000::/52.  The following two entries accomplish this.
</t>

<figure anchor="fig_policy_table" title="Policy table entries to implement a routing policy" align="center">
<artwork align="center"><![CDATA[
Prefix                 Precedence       Label            
2001:db8:0:1234::/64   50               33
2001:db8:0:a000::/52   50               33
]]></artwork>
</figure>

<t> This requires that the hosts implement <xref target="RFC6724"/>, the basic source and destination 
address framework, along with <xref target="RFC7078"/>, the DHCPv6 extension for distributing a 
non-default policy table.  Note that it does NOT require that the hosts use DHCPv6 for address assignment.
The hosts could still use stateless address autoconfiguration for address configuration, while  
using DHCPv6 only for policy table distribution (see <xref target="RFC3736"/>).  
</t>
</section>

<section anchor="sec_both_working_ra" title="Controlling Source Address Selection With Router Advertisements">
<t> Neighbor Discovery currently has two mechanisms to communicate 
prefix information to hosts. The base specification for Neighbor Discovery (see <xref target="RFC4861"/>)
defines the Prefix Information Option (PIO) in the Router Advertisement (RA) message. 
When a host
receives a PIO with the A-flag set, it can use the prefix in the PIO as source prefix 
from which it assigns itself an IP address using stateless address autoconfiguration (SLAAC) procedures
described in <xref target="RFC4862"/>.  In the example of <xref target="fig_isp_service"/>,
if the site network is using SLAAC,
we would expect both R1 and R2 to send RA messages with PIOs for both source prefixes
2001:db8:0:a010::/64 and 2001:db8:0:b010::/64 with the A-flag set.  H31 would then 
use the SLAAC procedure to configure itself with the 2001:db8:0:a010::31  
and 2001:db8:0:b010::31.  
</t>

<t> Whereas a host learns about source prefixes from PIO messages,  hosts 
can learn about a destination prefix from a Router Advertisement containing
Route Information Option (RIO), as specified in <xref target="RFC4191"/>.  
The destination prefixes in RIOs are intended to allow a host to choose 
the router that it uses as its first hop to reach a particular destination prefix.  
</t>

<t> As currently standardized, neither PIO nor RIO options contained in Neigbor Discovery
Router Advertisements can communicate the information needed to implement the desired
routing policy.  PIO's communicate source prefixes, and RIO communicate destination prefixes.
However, there is currently no standardized way to associate a particular destination prefix
with a particular source prefix.  
</t>

<t> <xref target="I-D.pfister-6man-sadr-ra"/> 
proposes a Source Address Dependent Route Information option for 
Neighbor Discovery Router Advertisements which would associate a source 
prefix and with a destination prefix.  The details of 
<xref target="I-D.pfister-6man-sadr-ra"/> might need tweaking to address 
this use case.  However, in order to be able to use Neighbor Discovery 
Router Advertisements to implement this routing policy, an extension that
allows a R1 and R2 to explicitly communicate to H31 an association between 
S=2001:db8:0:a000::/52 D=2001:db8:0:1234::/64 would be needed.
</t>

</section>

<section anchor="sec_both_working_icmpv6" title="Controlling Source Address Selection With ICMPv6">
<t> We now dicuss how one might use ICMPv6 to implement the routing policy to 
send traffic destined for H101 out the uplink to ISP-A, even when uplinks to both 
ISPs are working.  If H31 started sending traffic to H101 with 
S=2001:db8:0:b010::31 and D=2001:db8:0:1234::101, it would be routed through SER-b1 
and out the uplink to ISP-B.  SERb1 could recognize that this is traffic 
is not following the desired routing policy and react by sending an ICMPv6 message
back to H31. 
</t>

<t> In this example, we could arrange things so that SERb1 drops the packet with 
S=2001:db8:0:b010::31 and D=2001:db8:0:1234::101, and then sends to H31 an 
ICMPv6 Destination Unreachable message with Code 5 (Source address failed ingress/egress policy).
When H31 receives this packet, it would then be expected to try another source address to 
reach the destination.  In this example, H31 would then send a packet with 
S=2001:db8:0:a010::31 and D=2001:db8:0:1234::101, which will reach SERa and be
forwarded out the uplink to ISP-A.  
</t>

<t> However, we would also want it to be the case that SERb1 does not enforce
this routing policy when the uplink from SERa to ISP-A has failed.  This could 
be accomplished by having SERa originate a source-prefix-scoped route for 
(S=2001:db8:0:a000::/52, D=2001:db8:0:1234::/64) and have SERb1 monitor the
presence of that route.  If that route is not present (becuase SERa has 
stopped originating it), then SERb1 will
not enforce the routing policy, and it will forward packets with 
S=2001:db8:0:b010::31 and D=2001:db8:0:1234::101 out its uplink to ISP-B.  
</t>

<t> We can also use this source-prefix-scoped route originated by SERa to 
communicate the desired routing policy to SERb1.  We can define 
an EXCLUSIVE flag to be advertised together with the IGP route for
(S=2001:db8:0:a000::/52, D=2001:db8:0:1234::/64).  This would allow SERa 
to communicate to SERb that SERb should reject traffic for  
D=2001:db8:0:1234::/64 and respond with an ICMPv6 Destination Unreachable 
Code 5 message, as long as the route
for (S=2001:db8:0:a000::/52, D=2001:db8:0:1234::/64) is present.
</t>

<t> Finally, if we are willing to extend ICMPv6 to support this solution, then
we could create a mechasism for SERb1 to tell the host what source address it 
should be using to successfully forward packets that meet the policy.  
In its current form, when SERb1 sends an ICMPv6 Destination Unreachable 
Code 5 message, it is basically saying, "This source address is wrong.  Try another 
source address."  It would be better is if the ICMPv6 message could say,
"This source address is wrong.  Instead use a source address in S=2001:db8:0:a000::/52."
</t>

</section>

<section anchor="sec_both_working_summary" title="Summary of Methods For Controlling Source 
Address Selection To Implement Routing Policy">

<t> So to summarize this section, we have looked at three methods for 
implementing a simple routing policy where all traffic for a given 
destination on the Internet needs to use a particular ISP, even when the 
uplinks to both ISPs are working. 
</t>

<t>
The default source address selection policy cannot distinguish between 
the source addresses needed to enforce this policy, so a non-default 
policy table using associating source and destination prefixes using 
Label values would need to be installed on each host. A standards exists 
for DHCPv6 to distribute a non-default policy table, but it is not clear 
if they are widely implemented in host operating systems. 
</t>

<t>
Currently standardized options in Neighbor Discovery Router Advertisements do not 
allow particular source prefixes to be associated with particular 
destination prefixes. If we wanted to use Router Advertisements to 
enforce routing policy in multihomed networks, we would need 
standardization of such an option, and host operating systems would need 
to implement this.
</t>


<t> SERs can enforce the routing policy by sending ICMPv6 Destination 
Unreachable messages with Code 5 (Source address failed ingress/egress 
policy) for traffic that is being sent to the wrong ISP. The policy 
distribution can be automated by defining an EXCLUSIVE flag for the 
source-prefix-scoped route which can be set on the SER that originates 
the route. 
</t>


</section>

</section>

<section anchor="sec_one_uplink_failed" title="Selecting Source Address When One Uplink Has Failed">
<t> Now we look at how DHCPv6, Neighbor Discovery Router Advertisements, and ICMPv6 can 
help a host choose the right source address when an uplink to one of the ISPs has failed.  Again 
we look at the scenario in <xref target="fig_isp_service"/>.  This time we
look at traffic from H31 destined for external host H501 at D=2001:db8:0:5678::501.  We 
initially assume that the uplink from SERa to ISP-A is working and that
the uplink from SERb1 to ISP-B is working.  
</t>

<t> We assume there is no 
particular routing policy desired, so H31 is free to send packets with 
S=2001:db8:0:a010::31 or S=2001:db8:0:b010::31 and have them 
delivered to H501.  For this example, we assume that H31 has chosen 
S=2001:db8:0:b010::31 so that the packets exit via SERb to ISP-B.  Now we 
see what happens when the link from SERb1 to ISP-B fails.  How should H31 learn
that it needs to start sending the packet to H501 with S=2001:db8:0:a010::31 in 
order to start using the uplink to ISP-A?  We need to do this 
in a way that doesn't prevent H31 from still sending packets with
S=2001:db8:0:b010::31 in order to reach H61 at D=2001:db8:0:6666::61.  
</t>

<section anchor="sec_one_uplink_failed_dhcpv6" title="Controlling Source Address Selection With DHCPv6">
<t> For this 
example we assume that the site network in <xref target="fig_isp_service"/> has
a centralized DHCP server and all routers act as DHCP relay agents.  
We assume that both of the addresses assigned to H31 were assigned via DHCP.
</t>
<t>  We could try to have the DHCP server monitor the state of the uplink 
from SERb1 to ISP-B in some manner and then tell H31 that it can no longer
use S=2001:db8:0:b010::31 by settings its valid lifetime 
to zero. The DHCP server could initiate this process by sending a 
Reconfigure Message to H31 as described in Section 19 of <xref target="RFC3315"/>.  
Or the DHCP server can assign addresses with short lifetimes in
order to force clients to renew them often. 
</t>

<t>  This approach would prevent H31 from using S=2001:db8:0:b010::31 to reach 
the a host on the internet.  However, it would also prevent H31 from using 
S=2001:db8:0:b010::31 to reach H61 at D=2001:db8:0:6666::61, which is not desirable.
</t>

<t>  Another potential approach is to have have the DHCP server 
monitor the uplink from SERb1 to ISP-B and and control the choice of 
source address on H31 by updating its 
address selection policy table via the mechanism in <xref target="RFC7078"/>.
The DHCP server could initiate
this process by sending a Reconfigure Message to H31.
Note that <xref target="RFC3315"/> requires that Reconfigure Message use DHCP
authentication.  DHCP authentication could be avoided by using
short address lifetimes to force clients to 
send Renew messages to the server often. If the host is not obtaining its
IP addresses from the DHCP server, then it would need to use the Information Refresh Time
option defined in <xref target="RFC4242"/>.
</t>

<t> If the following policy table can be installed on H31 after the 
failure of the uplink from SERb1, then the desired routing behavior should 
be acheived based on source and destination prefix being matched with label values.
</t>

<figure anchor="fig_policy_table_failed_uplink" title="Policy Table Needed 
On Failure Of Uplink From SERb1 " align="center">
<artwork align="center"><![CDATA[
Prefix                 Precedence       Label            
::/0                   50               44
2001:db8:0:a000::/52   50               44
2001:db8:0:6666::/64   50               55
2001:db8:0:b000::/52   50               55

]]></artwork>
</figure>

<t>  As mentioned before, it does not appear that <xref target="RFC7078"/>
 has been widely implemented on host operating systems.  In addition, 
 <xref target="RFC7078"/> does not clearly specify this kind of a dynamic 
 use case where address selection policy needs to be updated quickly in
 response to the failure of a link.
 If we were to rely on this mechanism as an integral
 part of this multihoming solution, <xref target="RFC7078"/> should be
 updated to more clearly specify the expected behavior in the failure
 scenario discussed above.
</t>

</section>

<section anchor="sec_one_uplink_failed_ra" title="Controlling Source Address Selection With 
Router Advertisements">
<t> As noted in  <xref target="sec_both_working_ra"/>,
there is currently no standardized way to associate a particular destination prefix
with a particular source prefix in a Neighbor Discovery Router Advertisement.  Therefore, 
we can't currently send an RA message to selectively disable the use of S=2001:db8:0:b010::/64
on packets to all destination addresses, except for packets sent to D=2001:db8:0:6666::/64.  
This could be remedied with a proposal along the lines of <xref target="I-D.pfister-6man-sadr-ra"/>. 
</t>

<t> However, Stateless Address Autoconfiguration presents another difficulty for using
Router Advertisements to rapidly invalidate a prefix in response to the failure
of an uplink.  In particular, section 5.3.3 
of <xref target="RFC4862"/> prevents a host from setting the valid lifetime of a prefix 
to a value less than 2 hours based on Prefix Information option received in an RA, unless the 
RA has been authenticated, for example using Secure Neighbor Discovery. 
 The goal is to prevent denial-of-service attacks.  Similar logic 
would apply to a new RA option that associates source and destination prefixes and require 
authentication.
</t>
</section>

<section anchor="sec_one_uplink_failed_icmp" title="Controlling Source Address Selection With 
ICMPv6">
<t> Now we look at how ICMPv6 messages can provide informatation back to H31.
We assume again that at the time of the failure
H31 is sending packets to H501 using (S=2001:db8:0:b010::31, D=2001:db8:0:5678::501).
When the uplink from SERb1 to ISP-B fails, SERb1 would 
stop originating its source-prefix-scoped route for the default destination 
(S=2001:db8:0:b000::/52, D=::/0) as well as its unscoped 
default destination route. With these routes no longer in the IGP, traffic with 
(S=2001:db8:0:b010::31, D=2001:db8:0:5678::501) would end up at SERa based on the 
unscope default destination route being originated by SERa.  Since that traffic
has the wrong source address to be forwarded to ISP-A, SERa would drop it and send a 
Destination Unreachable message with Code 5 (Source address failed ingress/egress policy) 
back to H31.  H31 would then know to use another source address for that destination and would  
try with (S=2001:db8:0:a010::31, D=2001:db8:0:5678::501).  This would be forwarded to
SERa based on the source-prefix-scoped default destination route still being originated 
by SERa, and SERa would forward it to ISP-A.  As discussed above, if we are willing to extend ICMPv6,
SERa can even tell H31 what source address it should use to reach that destination.
</t>

</section>

<section anchor="sec_uplink_failed_summary" title="Summary Of Methods For Controlling Source 
Address Selection On The Failure Of An Uplink">

<t> Neither Neigbor Discovery Router Advertisements nor DHCPv6 is particularly well suited to 
quickly changing the source address used by a host in the event of the failure of an uplink.  
Both require the use of authentication to lessen the risk of denial-of-service attacks through this
vector.  And neither was really designed with this dynamic use case in mind.
</t>

<t> The use of ICMPv6 Destination Unreachable messages generated by the SER routers seem like they 
have the potential to provide a solution that works independent of the particulars of the address 
configuration method. 
</t>

<t> The current behavior of different host operating system when receiving 
ICMPv6 Destination Unreachable message with code 5 
(Source address failed ingress/egress policy) is not clear to the authors.
Information from implementers, users, and testing would be quite helpful 
in evaluating this approach. 
</t>
</section>

</section>

</section>

<section anchor="sec_shim6" title="Shim6">

<t>The Shim6 working group specified the Shim6 protocol <xref target="RFC5533"/> 
which allows a host at a multihomed
site to communicate with an external host and exchange information about 
possible source and destination address pairs that they can use to communicate.
It also specified the REAP protocol <xref target="RFC5534"/> to 
detect failures in the path between working address pairs and find
new working address pairs.  A fundamental requirement for Shim6 is 
that both internal and external hosts need to support Shim6.
That is, both the host internal to the 
multihomed site and the host external to the multihomed site need to 
support Shim6 in order for there to be any benefit for the internal host
to run Shim6.  The Shim6 protocol specification was published 
in 2009, but it has not been implemented on widely used operating systems.  
</t>
  
<t>We do not consider Shim6 to be a viable solution.  It suffers from the fact
that it requires widespread deployment of Shim6 on hosts all over the Internet 
before the host at a PA multihomed site sees significant benefit.  However, there
appears to be no motivation for the vast majority of hosts on the 
Internet (which are not at PA multihomed sites) to deploy Shim6.
This may help explain why Shim6 has not been widely implemented.  
</t>

</section>


<section anchor="sec_nptv6" title="IPv6-to-IPv6 Network Prefix Translation">

<t>IPv6-to-IPv6 Network Prefix Translation is not the focus of this 
document. This document describes a solution where a host in a 
multihomed site determines which ISP a packet will be sent to based on 
the source address it applies to the packet. This solution has many 
moving parts. It requires 
some routers in the enterprise site to support some  
form of Source Address Dependent Routing (SADR). It requires a host to 
be able to learn when the uplink to an ISP fails so that it can stop 
using the source address corresponding to that ISP. Ongoing work to 
create mechansisms to accomplish this are discussed in this document, 
but they are still a work in progress. 
</t>

<t> This document attempts to create a PA multihoming 
solution that is as easy as possible for an enterprise to deploy. However, 
the success of this solution will depend greatly on whether or not the 
 mechanisms for hosts to select source addresses based 
on the state of ISP uplinks gets implemented across a wide range of 
operating systems as the default mode of operation.
Until that occurs, NPTv6 should still be 
considered a viable option to enable PA multihoming for enterprises. 
</t>

</section>
	

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo asks the IANA for no new parameters.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t/>

      <section anchor="Privacy" title="Privacy Considerations">
        <t/>
      </section>
	  
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The original outline was suggested by Ole Troan. 
  	  </t>
    </section>
  </middle>

  <back>
    <!-- references split to informative and normative -->

<references title="Normative References">
<?rfc include="reference.RFC.2827" ?>

<?rfc include="reference.RFC.4193" ?>

<?rfc include="reference.RFC.6296" ?>

<?rfc include="reference.RFC.1918" ?>

<?rfc include="reference.RFC.1122" ?>

<?rfc include="reference.RFC.1123" ?>

<?rfc include="reference.RFC.2119"?>

<?rfc include="reference.RFC.2460"?>

<?rfc include="reference.RFC.3315" ?>

<?rfc include="reference.RFC.3582" ?>

<?rfc include="reference.RFC.4116" ?>

<?rfc include="reference.RFC.4191" ?>

<?rfc include="reference.RFC.4242" ?>

      <?rfc include="reference.RFC.4218" ?>

      <?rfc include="reference.RFC.4219" ?>

      <?rfc include="reference.RFC.7157" ?>
    </references>

    <references title="Informative References">

      <?rfc include="reference.I-D.pfister-6man-sadr-ra" ?>

      <?rfc include="reference.I-D.huitema-shim6-ingress-filtering" ?>

      <?rfc include="reference.I-D.baker-ipv6-isis-dst-src-routing" ?>

      <?rfc include="reference.I-D.baker-rtgwg-src-dst-routing-use-cases" ?>

      <?rfc include="reference.I-D.boutier-babel-source-specific" ?>

      <?rfc include="reference.I-D.ietf-6man-multi-homed-host" ?>

      <?rfc include="reference.I-D.ietf-mif-mpvd-arch" ?>

      <?rfc include="reference.I-D.ietf-mptcp-experience" ?>

      <?rfc include="reference.I-D.ietf-rtgwg-dst-src-routing" ?>

      <?rfc include="reference.I-D.xu-src-dst-bgp" ?>

      <?rfc include="reference.RFC.4443" ?>
 
      <?rfc include="reference.RFC.3736" ?>

      <?rfc include="reference.RFC.4861" ?>

      <?rfc include="reference.RFC.5533" ?>

      <?rfc include="reference.RFC.5534" ?>

      <?rfc include="reference.RFC.4862" ?>

      <?rfc include="reference.RFC.6555" ?>

      <?rfc include="reference.RFC.6724" ?>

      <?rfc include="reference.RFC.7078" ?>
	  
      <?rfc include="reference.RFC.7788" ?>

      <?rfc include="reference.RFC.4941" ?>
	  
      <reference anchor="PATRICIA">
        <front>
          <title>Practical Algorithm to Retrieve Information Coded in
          Alphanumeric</title>

          <author fullname="D.R. Morrison" initials="D.R." surname="Morrison">
            <organization>Association for Computing Machinery</organization>
          </author>

          <date month="October" year="1968"/>
        </front>

        <seriesInfo name="Journal of the ACM" value="15(4) pp514-534"/>

        <format target="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA/"
                type="HTML"/>
      </reference>
    </references>

    <section anchor="log" title="Change Log">
      <t><list style="hanging">
          <t hangText="Initial Version:">June 2016</t>
        </list></t>
    </section>
  </back>
</rfc>
